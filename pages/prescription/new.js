// /pages/prescription/new.js
'use client';
import * as React from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import {
  Box,
  Container,
  Stack,
  Typography,
  Paper,
  Button,
  TextField,
  Autocomplete,
  CircularProgress,
  Grid,
  IconButton,
  Snackbar,
  Alert,
  LinearProgress,
  Tooltip,
  MenuItem,
  InputAdornment,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  Chip,
  Fade,
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import DeleteOutlineIcon from '@mui/icons-material/DeleteOutline';
import MedicationIcon from '@mui/icons-material/Medication';
import ScienceIcon from '@mui/icons-material/Science';
import PrintIcon from '@mui/icons-material/Print';
import WhatsAppIcon from '@mui/icons-material/WhatsApp';
import PersonIcon from '@mui/icons-material/Person';
import AddPhotoAlternateIcon from '@mui/icons-material/AddPhotoAlternate';
import NoteAltIcon from '@mui/icons-material/NoteAlt';
import EventIcon from '@mui/icons-material/Event';
import HealingIcon from '@mui/icons-material/Healing';
import FavoriteIcon from '@mui/icons-material/Favorite';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import { alpha } from '@mui/material/styles';
import { uploadImageToImgbb } from '@/components/reports/utils/imgbb';
import { db } from '@/lib/firebase';
import {
  collection,
  query,
  where,
  onSnapshot,
  doc,
  getDoc,
  addDoc,
  updateDoc,
  arrayUnion,
  serverTimestamp,
} from 'firebase/firestore';
import AppLayout from '@/components/AppLayout';
import Protected from '@/components/Protected';
import { useAuth } from '@/providers/AuthProvider';

export default function NewPrescriptionPage() {
  const router = useRouter();
  const { user } = useAuth();

  const isArabic = React.useMemo(() => {
    const q = router?.query || {};
    if (q.lang) return String(q.lang).toLowerCase().startsWith('ar');
    if (q.ar) return q.ar === '1' || String(q.ar).toLowerCase() === 'true';
    return true;
  }, [router.query]);

  const t = React.useCallback((en, ar) => (isArabic ? ar : en), [isArabic]);
  const dir = isArabic ? 'rtl' : 'ltr';

  // State
  const [patients, setPatients] = React.useState([]);
  const [patientsLoading, setPatientsLoading] = React.useState(false);
  const [selectedPatient, setSelectedPatient] = React.useState(null);
  const [patientInfo, setPatientInfo] = React.useState({ mrn: '', sex: '', dobStr: '', phone: '' });

  // Form state (all fields from dialog)
  const [form, setForm] = React.useState({
    titleAr: '',
    titleEn: '',
    dateStr: '',
    diagnosis: '',
    findings: '',
    procedures: '',
    chiefComplaint: '',
    vitalsBP: '',
    vitalsHR: '',
    vitalsTemp: '',
    vitalsSpO2: '',
  });

  // Attachment state
  const [previewURL, setPreviewURL] = React.useState('');
  const [fileName, setFileName] = React.useState('');
  const [imgbbURL, setImgbbURL] = React.useState('');
  const [attaching, setAttaching] = React.useState(false);

  // Vitals extra fields
  const [extraVitalsFields, setExtraVitalsFields] = React.useState([]);
  const [vitalsDialogOpen, setVitalsDialogOpen] = React.useState(false);
  const [selectedVitalField, setSelectedVitalField] = React.useState('');
  const [customVitalField, setCustomVitalField] = React.useState('');

  // AI suggestions for clinical fields
  const [aiSuggestions, setAiSuggestions] = React.useState({ field: '', items: [] });
  const [aiLoading, setAiLoading] = React.useState(false);
  const [titleAutoGenerated, setTitleAutoGenerated] = React.useState({ ar: false, en: false });
  const [titleGenerating, setTitleGenerating] = React.useState(false);

  const [medicationsList, setMedicationsList] = React.useState([
    { name: '', dose: '', frequency: '', duration: '', notes: '' },
  ]);

  const [testsList, setTestsList] = React.useState([{ name: '', notes: '' }]);

  const [drugOptions, setDrugOptions] = React.useState([]);
  const [drugLoading, setDrugLoading] = React.useState(true);

  const [allTests, setAllTests] = React.useState([]);
  const [testsLoading, setTestsLoading] = React.useState(true);

  const [submitting, setSubmitting] = React.useState(false);
  const [snack, setSnack] = React.useState({ open: false, msg: '', severity: 'success' });
  const [errors, setErrors] = React.useState({});
  
  // Doctor specialty
  const [doctorSpecialty, setDoctorSpecialty] = React.useState({ key: '', ar: '', en: '' });

  // Load doctor specialty
  React.useEffect(() => {
    if (!user?.uid) return;
    
    let isMounted = true;
    
    const loadDoctorSpecialty = async () => {
      try {
        const docSnap = await getDoc(doc(db, 'doctors', user.uid));
        if (!isMounted) return;
        
        if (docSnap.exists()) {
          const data = docSnap.data();
          setDoctorSpecialty({
            key: data.specialty_key || '',
            ar: data.specialty_ar || '',
            en: data.specialty_en || '',
          });
        }
      } catch (err) {
        console.error('Failed to load doctor specialty:', err);
      }
    };
    
    loadDoctorSpecialty();
    
    return () => { isMounted = false; };
  }, [user?.uid]);

  // Load patients
  React.useEffect(() => {
    if (!user?.uid) return;

    let isMounted = true;
    let unsub1 = null;
    let unsub2 = null;

    setPatientsLoading(true);
    
      const col = collection(db, 'patients');
      const q1 = query(col, where('associatedDoctors', 'array-contains', user.uid));
      const q2 = query(col, where('registeredBy', '==', user.uid));

    let data1 = [];
    let data2 = [];

    const updatePatients = () => {
      if (!isMounted) return;

          const combined = [...data1, ...data2];
          const unique = Object.values(
            combined.reduce((acc, cur) => {
              acc[cur.id] = cur;
              return acc;
            }, {})
          );

          const withPhone = unique.filter(
            (p) => typeof p.phone === 'string' && p.phone.trim() !== ''
          );

          withPhone.sort((a, b) =>
            (a?.name ?? '').localeCompare(b?.name ?? '', undefined, { sensitivity: 'base' })
          );

          setPatients(withPhone);
          setPatientsLoading(false);
    };

    try {
      unsub1 = onSnapshot(q1, (snap1) => {
        if (!isMounted) return;
        data1 = snap1.docs.map((d) => ({ id: d.id, ...d.data() }));
        updatePatients();
      }, (err) => {
        console.error('Error loading associated patients:', err);
        if (isMounted) {
          setPatientsLoading(false);
        }
      });

      unsub2 = onSnapshot(q2, (snap2) => {
        if (!isMounted) return;
        data2 = snap2.docs.map((d) => ({ id: d.id, ...d.data() }));
        updatePatients();
      }, (err) => {
        console.error('Error loading registered patients:', err);
        if (isMounted) {
          setPatientsLoading(false);
        }
      });
    } catch (err) {
      console.error(err);
      if (isMounted) {
      setPatientsLoading(false);
    }
    }

    return () => {
      isMounted = false;
      if (unsub1) unsub1();
      if (unsub2) unsub2();
    };
  }, [user?.uid]);

  // Fetch patient demographics
  const fetchPatientInfo = React.useCallback(async (patientId) => {
    try {
      if (!patientId) {
        setPatientInfo({ mrn: '', sex: '', dobStr: '', phone: '' });
        return;
      }

      const snap = await getDoc(doc(db, 'patients', patientId));
      const data = snap.exists() ? snap.data() : {};

      const dob =
        data?.dob instanceof Date
          ? data.dob
          : data?.dob?.toDate
          ? data.dob.toDate()
          : data?.dob
          ? new Date(data.dob)
          : null;

      const dobStr = dob && !isNaN(dob.getTime()) ? dob.toISOString().slice(0, 10) : '';

      // Normalize phone number with +20 (Egypt country code) if not already normalized
      const normalizePhoneForDisplay = (raw = '') => {
        const s = String(raw || '').trim();
        if (!s) return '';
        // If already starts with +20, return as is
        if (s.startsWith('+20') && s.length > 3) return s;
        const d = s.replace(/\D/g, '');
        if (!d) return s; // Return original if no digits
        let phoneDigits = d.replace(/^0+/, '');
        if (phoneDigits.startsWith('20')) return `+${phoneDigits}`;
        else return `+20${phoneDigits}`;
      };
      
      const phone = data?.phone || data?.mobile || '';
      setPatientInfo({
        mrn: data?.mrn || data?.medicalRecordNumber || '',
        sex: data?.sex || data?.gender || '',
        dobStr,
        phone: normalizePhoneForDisplay(phone),
      });
    } catch (err) {
      console.error(err);
    }
  }, []);

  // Store patientId from appointment to use when patients are loaded
  const [pendingPatientId, setPendingPatientId] = React.useState(null);

  // Fetch patientId from appointment if appointmentId is provided
  React.useEffect(() => {
    let isMounted = true;
    
    const appointmentId = router.query?.appointmentId;
    const patientIdFromQuery = router.query?.patientId;
    
    console.log('[Prescription] Router query:', { appointmentId, patientIdFromQuery });
    
    // If patientId is directly provided, use it
    if (patientIdFromQuery) {
      console.log('[Prescription] Setting pendingPatientId from query:', patientIdFromQuery);
      if (isMounted) {
      setPendingPatientId(String(patientIdFromQuery));
      }
      return () => { isMounted = false; };
    }
    
    // If appointmentId is provided but patientId is not, fetch patientId from appointment
    if (appointmentId && !patientIdFromQuery) {
      console.log('[Prescription] Fetching appointment:', appointmentId);
      (async () => {
        try {
          const apptSnap = await getDoc(doc(db, 'appointments', String(appointmentId)));
          if (!isMounted) return;
          
          if (apptSnap.exists()) {
            const apptData = apptSnap.data();
            const apptPatientId = apptData.patientId || apptData.patientUID || apptData.patientID;
            console.log('[Prescription] Appointment data:', { 
              patientId: apptData.patientId, 
              patientUID: apptData.patientUID, 
              patientID: apptData.patientID,
              resolved: apptPatientId 
            });
            if (apptPatientId && isMounted) {
              console.log('[Prescription] Setting pendingPatientId from appointment:', apptPatientId);
              setPendingPatientId(String(apptPatientId));
            }
          } else {
            console.warn('[Prescription] Appointment not found:', appointmentId);
          }
        } catch (err) {
          console.error('[Prescription] Failed to load appointment for patient selection:', err);
        }
      })();
    }
    
    return () => { isMounted = false; };
  }, [router.query?.appointmentId, router.query?.patientId]);

  // Cleanup object URL on unmount to prevent memory leaks
  React.useEffect(() => {
    return () => {
      if (previewURL) {
        URL.revokeObjectURL(previewURL);
      }
    };
  }, [previewURL]);

  // Auto-select patient when patients are loaded and we have a pending patientId
  React.useEffect(() => {
    console.log('[Prescription] Auto-select check:', { 
      selectedPatient: !!selectedPatient, 
      pendingPatientId, 
      patientsCount: patients.length 
    });
    
    if (selectedPatient) {
      console.log('[Prescription] Patient already selected, skipping');
      return;
    }
    
    if (!pendingPatientId) {
      console.log('[Prescription] No pendingPatientId, skipping');
      return;
    }
    
    if (patients.length === 0) {
      console.log('[Prescription] Patients not loaded yet, skipping');
      return;
    }
    
    console.log('[Prescription] Searching for patient with ID:', pendingPatientId);
    console.log('[Prescription] Patients list:', patients.map(p => ({ id: p.id, name: p.name })));
    
    const patient = patients.find((p) => {
      const pId = String(p.id || '').trim();
      const pendingId = String(pendingPatientId || '').trim();
      return pId === pendingId || pId === String(pendingId);
    });
    
    if (patient) {
      console.log('[Prescription] ✅ Patient found, setting:', patient.name, 'ID:', patient.id);
      setSelectedPatient(patient);
      fetchPatientInfo(patient.id);
    } else {
      console.warn('[Prescription] ❌ Patient not found in patients list.');
      console.warn('[Prescription] Looking for:', pendingPatientId);
      console.warn('[Prescription] Available IDs:', patients.map(p => ({ id: p.id, name: p.name })));
    }
  }, [pendingPatientId, patients, selectedPatient, fetchPatientInfo]);

  // Load medicines
  React.useEffect(() => {
    const loadMedicines = async () => {
      try {
        const res = await fetch('/data/medicines.min.json');
        const json = await res.json();
        setDrugOptions(json);
      } catch (err) {
        console.error('Failed loading medicines:', err);
      } finally {
        setDrugLoading(false);
      }
    };
    loadMedicines();
  }, []);

  // Load tests
  React.useEffect(() => {
    const loadTests = async () => {
      try {
        const res = await fetch('/data/medical_tests_list.json');
        if (!res.ok) throw new Error('Failed to load test list');
        const data = await res.json();
        const names = data.map((t) => t.TestName?.trim()).filter(Boolean);
        setAllTests(names);
      } catch (err) {
        console.error('Error loading JSON:', err);
        setAllTests([]);
      } finally {
        setTestsLoading(false);
      }
    };
    loadTests();
  }, []);

  // Medications handlers
  const addMedication = () =>
    setMedicationsList((prev) => [
      ...prev,
      { name: '', dose: '', frequency: '', duration: '', notes: '' },
    ]);

  const removeMedication = (i) =>
    setMedicationsList((prev) => prev.filter((_, idx) => idx !== i));

  const updateMedication = (i, key, val) =>
    setMedicationsList((prev) =>
      prev.map((m, idx) => (idx === i ? { ...m, [key]: val } : m))
    );

  // Tests handlers
  const addTest = () => setTestsList((prev) => [...prev, { name: '', notes: '' }]);

  const removeTest = (i) => setTestsList((prev) => prev.filter((_, idx) => idx !== i));

  const updateTest = (i, key, val) =>
    setTestsList((prev) => prev.map((m, idx) => (idx === i ? { ...m, [key]: val } : m)));

  // Filter drugs
  const filterDrugs = React.useCallback((q = '', list = []) => {
    const n = q.toLowerCase().trim();
    if (!n) return list.slice(0, 100);
    return list
      .filter(
        (d) =>
          d.displayName?.toLowerCase().includes(n) ||
          d.genericName?.toLowerCase().includes(n) ||
          d.brandName?.toLowerCase().includes(n)
      )
      .slice(0, 100);
  }, []);

  // Filter tests
  const filterTests = React.useCallback((q = '') => {
    if (!q) return allTests.slice(0, 50);
    const qLower = q.toLowerCase();
    return allTests.filter((t) => t.toLowerCase().includes(qLower)).slice(0, 30);
  }, [allTests]);

  // Form change handler
  const handleFormChange = (key) => (e) => {
    const val = e.target.value;
    setForm((f) => ({ ...f, [key]: val }));
    setErrors((prev) => ({ ...prev, [key]: undefined }));
    
    // AI suggestions for clinical fields
    if (['diagnosis', 'findings', 'procedures', 'chiefComplaint'].includes(key)) {
      const debounceRef = setTimeout(() => {
        fetchAiSuggestions(key, val);
      }, 600);
      return () => clearTimeout(debounceRef);
    }
  };

  // Handle field focus - show mockups immediately for all fields
  const handleFieldFocus = (field) => () => {
    loadFieldMockups(field);
  };

  // Component to render AI suggestions above any field
  const AISuggestionsBox = ({ field, onSelect }) => {
    if (aiSuggestions.field !== field) return null;
    
    if (aiLoading) {
      return (
        <Box sx={{ mb: 1.5, textAlign: 'center', py: 1 }}>
          <CircularProgress size={20} sx={{ color: '#8a4baf' }} />
        </Box>
      );
    }

    if (aiSuggestions.items.length === 0) return null;

    return (
      <Fade in timeout={400}>
        <Paper 
          elevation={0}
          sx={{ 
            mb: 1.5, 
            p: 2, 
            borderRadius: 3, 
            background: 'linear-gradient(135deg, rgba(138, 75, 175, 0.08) 0%, rgba(186, 104, 200, 0.05) 100%)',
            border: '1.5px solid',
            borderColor: 'rgba(138, 75, 175, 0.2)',
            boxShadow: '0 4px 12px rgba(138, 75, 175, 0.1)',
          }}
        >
          <Stack direction="row" spacing={1} alignItems="center" sx={{ mb: 1 }}>
            <AutoAwesomeIcon fontSize="small" sx={{ color: '#8a4baf' }} />
            <Typography variant="caption" fontWeight={700} color="#8a4baf">
              {t('AI Suggestions', 'اقتراحات الذكاء الاصطناعي')}
            </Typography>
          </Stack>
          <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
            {aiSuggestions.items
              .map(s => {
                // Helper function to extract text from JSON-like strings
                const extractText = (text) => {
                  let result = String(text || '').trim();
                  
                  // Skip common JSON/technical keywords
                  const skipKeywords = ['json', 'JSON', 'array', 'object', 'string', 'null', 'true', 'false'];
                  if (skipKeywords.includes(result.toLowerCase())) {
                    return '';
                  }
                  
                  // Match patterns like: "chief_complaint": "text here" or {"field": "text"}
                  // Skip if field name is a JSON keyword
                  const jsonMatch1 = result.match(/["']?([\w_]+)\s*["']?\s*:\s*["']([\s\S]*?)["']/);
                  if (jsonMatch1 && jsonMatch1[1] && jsonMatch1[2] && 
                      !skipKeywords.includes(jsonMatch1[1].toLowerCase()) &&
                      jsonMatch1[2].trim().length > 0 &&
                      !skipKeywords.includes(jsonMatch1[2].trim().toLowerCase())) {
                    result = jsonMatch1[2];
                  }
                  
                  // Handle object notation: {"field": "value"} or {field: "value"}
                  // Extract the actual value, skip if it's a JSON keyword
                  const objMatch = result.match(/\{[\s\S]*?["']?([\w_]+)\s*["']?\s*:\s*["']([\s\S]*?)["'][\s\S]*?\}/);
                  if (objMatch && objMatch[1] && objMatch[2] && 
                      !skipKeywords.includes(objMatch[1].toLowerCase()) &&
                      objMatch[2].trim().length > 0 &&
                      !skipKeywords.includes(objMatch[2].trim().toLowerCase())) {
                    result = objMatch[2];
                  }
                  
                  // Handle patterns without quotes around the value (for Unicode text)
                  const noQuotesMatch = result.match(/["']?([\w_]+)\s*["']?\s*:\s*([\s\S]+?)(?:\s*[,}]\s*|$)/);
                  if (noQuotesMatch && noQuotesMatch[1] && noQuotesMatch[2] && 
                      !skipKeywords.includes(noQuotesMatch[1].toLowerCase()) &&
                      noQuotesMatch[2].trim().length > 5 &&
                      !skipKeywords.includes(noQuotesMatch[2].trim().toLowerCase())) {
                    const extracted = noQuotesMatch[2].trim().replace(/^["']|["']$/g, '');
                    if (extracted.length > 0) {
                      result = extracted;
                    }
                  }
                  
                  // If the result is still a JSON keyword, try to find actual content
                  if (skipKeywords.includes(result.toLowerCase())) {
                    // Try to extract from array notation: ["actual text", "json"]
                    const arrayMatch = result.match(/\[[\s\S]*?["']([\s\S]*?)["'][\s\S]*?\]/);
                    if (arrayMatch && arrayMatch[1] && !skipKeywords.includes(arrayMatch[1].trim().toLowerCase())) {
                      result = arrayMatch[1];
                    } else {
                      return ''; // Skip if it's just a keyword
                    }
                  }
                  
                  // Remove any remaining JSON structure indicators and quotes
                  result = result
                    .replace(/^["'`]|["'`]$/g, '') // Remove quotes at start/end
                    .replace(/^\s*["']?(json|JSON|array|object|string)\s*["']?\s*:\s*/i, '') // Remove JSON keyword prefixes
                    .replace(/^\s*["']?[\w_]+\s*["']?\s*:\s*/g, '') // Remove field: prefix
                    .replace(/^\s*\{|\}\s*$/g, '') // Remove braces
                    .replace(/^\s*\[|\]\s*$/g, '') // Remove brackets
                    .replace(/,\s*$/, '') // Remove trailing comma
                    .trim();
                  
                  // Final check: skip if it's a JSON keyword or too short
                  if (skipKeywords.includes(result.toLowerCase()) || result.length < 3) {
                    return '';
                  }
                  
                  return result;
                };
                
                // Ensure all items are strings and extract text from JSON-like strings
                let text = '';
                
                if (typeof s === 'object' && s !== null) {
                  const keys = Object.keys(s);
                  if (keys.length > 0) {
                    const firstValue = s[keys[0]];
                    text = typeof firstValue === 'string' ? firstValue : JSON.stringify(s);
                  } else {
                    text = JSON.stringify(s);
                  }
                } else {
                  text = String(s || '');
                }
                
                return extractText(text);
              })
              .filter(s => s && s.length > 0)
              .map((s, i) => (
              <Chip
                key={i}
                label={s}
                onClick={() => onSelect(s)}
                variant="outlined"
                sx={{
                  borderColor: '#8a4baf',
                  color: '#8a4baf',
                  fontWeight: 600,
                  borderRadius: '20px',
                  cursor: 'pointer',
                  transition: 'all 0.2s ease',
                  '&:hover': { 
                    bgcolor: '#8a4baf', 
                    color: '#fff', 
                    borderColor: '#8a4baf',
                    transform: 'translateY(-2px)',
                    boxShadow: '0 4px 8px rgba(138, 75, 175, 0.3)',
                  },
                }}
              />
            ))}
          </Stack>
        </Paper>
      </Fade>
    );
  };

  // Load AI suggestions mockups on field focus (no text needed)
  const loadFieldMockups = async (field) => {
    if (!doctorSpecialty.key && !doctorSpecialty.ar) {
      setAiSuggestions({ field: '', items: [] });
      return;
    }
    
    setAiLoading(true);
    setAiSuggestions({ field, items: [] });
    
    try {
      const token = user ? await user.getIdToken() : '';
      
      const specialtyName = isArabic ? doctorSpecialty.ar : doctorSpecialty.en;
      const specialtyKey = doctorSpecialty.key;
      
      // Field-specific prompts with specialty - generate mockups directly
      // Note: titleAr and titleEn are auto-generated, not via suggestions
      const fieldPrompts = {
        chiefComplaint: `Generate 5 professional chief complaint mockup/template examples for a ${specialtyName} (${specialtyKey}) specialist. These should be complete, ready-to-use sentences that a ${specialtyName} doctor would typically document. Return a JSON array of 5 complete mockup sentences in ${isArabic ? 'Arabic' : 'English'}.`,
        diagnosis: `Generate 5 professional diagnosis mockup/template examples for a ${specialtyName} (${specialtyKey}) specialist. Include common diagnoses with ICD codes if relevant. Return a JSON array of 5 complete diagnosis statements in ${isArabic ? 'Arabic' : 'English'}.`,
        findings: `Generate 5 clinical examination findings mockup/template examples for a ${specialtyName} (${specialtyKey}) specialist. These should be complete findings statements that a ${specialtyName} doctor would typically document. Return a JSON array of 5 complete findings statements in ${isArabic ? 'Arabic' : 'English'}.`,
        procedures: `Generate 5 medical procedures/treatments mockup/template examples for a ${specialtyName} (${specialtyKey}) specialist. Include common procedures with CPT codes if relevant. Return a JSON array of 5 complete procedure statements in ${isArabic ? 'Arabic' : 'English'}.`,
      };
      
      // Handle dynamic fields (if any remain in the future)
      let baseField = field;
      
      const prompt = fieldPrompts[baseField] || fieldPrompts[field] || `Generate 5 professional ${baseField || field} mockup examples for a ${specialtyName} specialist. Return a JSON array.`;
      
      const res = await fetch('/api/ask-shafy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(token ? { Authorization: `Bearer ${token}` } : {}),
        },
        body: JSON.stringify({
          message: prompt,
          lang: isArabic ? 'ar' : 'en',
          enable_rag: false,
          use_server_context: false,
        }),
      });

      const data = await res.json();
      const raw = data?.text || '';
      let parsed = [];

      // Helper function to extract text from JSON-like strings
      const extractText = (text) => {
        let result = String(text || '').trim();
        
        // Skip common JSON/technical keywords
        const skipKeywords = ['json', 'JSON', 'array', 'object', 'string', 'null', 'true', 'false'];
        if (skipKeywords.includes(result.toLowerCase())) {
          return '';
        }
        
        // Match patterns like: "chief_complaint": "text here" or {"field": "text"}
        // Skip if field name is a JSON keyword
        const jsonMatch1 = result.match(/["']?([\w_]+)\s*["']?\s*:\s*["']([\s\S]*?)["']/);
        if (jsonMatch1 && jsonMatch1[1] && jsonMatch1[2] && 
            !skipKeywords.includes(jsonMatch1[1].toLowerCase()) &&
            jsonMatch1[2].trim().length > 0 &&
            !skipKeywords.includes(jsonMatch1[2].trim().toLowerCase())) {
          result = jsonMatch1[2];
        }
        
        // Handle object notation: {"field": "value"} or {field: "value"}
        // Extract the actual value, skip if it's a JSON keyword
        const objMatch = result.match(/\{[\s\S]*?["']?([\w_]+)\s*["']?\s*:\s*["']([\s\S]*?)["'][\s\S]*?\}/);
        if (objMatch && objMatch[1] && objMatch[2] && 
            !skipKeywords.includes(objMatch[1].toLowerCase()) &&
            objMatch[2].trim().length > 0 &&
            !skipKeywords.includes(objMatch[2].trim().toLowerCase())) {
          result = objMatch[2];
        }
        
        // Handle patterns without quotes around the value (for Unicode text)
        const noQuotesMatch = result.match(/["']?([\w_]+)\s*["']?\s*:\s*([\s\S]+?)(?:\s*[,}]\s*|$)/);
        if (noQuotesMatch && noQuotesMatch[1] && noQuotesMatch[2] && 
            !skipKeywords.includes(noQuotesMatch[1].toLowerCase()) &&
            noQuotesMatch[2].trim().length > 5 &&
            !skipKeywords.includes(noQuotesMatch[2].trim().toLowerCase())) {
          const extracted = noQuotesMatch[2].trim().replace(/^["']|["']$/g, '');
          if (extracted.length > 0) {
            result = extracted;
          }
        }
        
        // If the result is still a JSON keyword, try to find actual content
        if (skipKeywords.includes(result.toLowerCase())) {
          // Try to extract from array notation: ["actual text", "json"]
          const arrayMatch = result.match(/\[[\s\S]*?["']([\s\S]*?)["'][\s\S]*?\]/);
          if (arrayMatch && arrayMatch[1] && !skipKeywords.includes(arrayMatch[1].trim().toLowerCase())) {
            result = arrayMatch[1];
          } else {
            return ''; // Skip if it's just a keyword
          }
        }
        
        // Remove any remaining JSON structure indicators and quotes
        result = result
          .replace(/^["'`]|["'`]$/g, '') // Remove quotes at start/end
          .replace(/^\s*["']?(json|JSON|array|object|string)\s*["']?\s*:\s*/i, '') // Remove JSON keyword prefixes
          .replace(/^\s*["']?[\w_]+\s*["']?\s*:\s*/g, '') // Remove field: prefix
          .replace(/^\s*\{|\}\s*$/g, '') // Remove braces
          .replace(/^\s*\[|\]\s*$/g, '') // Remove brackets
          .replace(/,\s*$/, '') // Remove trailing comma
          .trim();
        
        // Final check: skip if it's a JSON keyword or too short
        if (skipKeywords.includes(result.toLowerCase()) || result.length < 3) {
          return '';
        }
        
        return result;
      };

      try {
        const j = JSON.parse(raw);
        if (Array.isArray(j)) {
          parsed = j.map(item => {
            let text = '';
            if (typeof item === 'object' && item !== null) {
              // If item is an object, try to extract a string value
              const keys = Object.keys(item);
              if (keys.length > 0) {
                const firstValue = item[keys[0]];
                text = typeof firstValue === 'string' ? firstValue : JSON.stringify(item);
              } else {
                text = JSON.stringify(item);
              }
            } else {
              text = String(item || '');
            }
            return extractText(text);
          }).filter(Boolean);
        } else if (typeof j === 'object' && j !== null) {
          parsed = Object.values(j).map(item => {
            let text = '';
            if (typeof item === 'object' && item !== null) {
              text = JSON.stringify(item);
            } else {
              text = String(item || '');
            }
            return extractText(text);
          }).filter(Boolean);
        } else if (typeof j === 'string') {
          parsed = j.split(/[\n,]+/).map(x => extractText(x.trim())).filter(x => x.length > 1);
        }
      } catch {
        const skipKeywords = ['json', 'JSON', 'array', 'object', 'string', 'null', 'true', 'false'];
        parsed =
          raw
            ?.split(/[\n,]+/)
            ?.map((x) => {
              // Extract text from JSON-like strings even in catch block
              // Use improved pattern to handle Unicode/Arabic text
              let text = x.trim();
              
              // Skip if it's a JSON keyword
              if (skipKeywords.includes(text.toLowerCase())) {
                return '';
              }
              
              const jsonMatch = text.match(/["']?([\w_]+)\s*["']?\s*:\s*["']([\s\S]*?)["']/);
              if (jsonMatch && jsonMatch[1] && jsonMatch[2] && 
                  !skipKeywords.includes(jsonMatch[1].toLowerCase()) &&
                  !skipKeywords.includes(jsonMatch[2].trim().toLowerCase())) {
                text = jsonMatch[2];
              }
              
              text = text
                .replace(/^["'`]|["'`]$/g, '') // Remove quotes at start/end
                .replace(/^\s*["']?(json|JSON|array|object|string)\s*["']?\s*:\s*/i, '') // Remove JSON keyword prefixes
                .replace(/^\s*["']?[\w_]+\s*["']?\s*:\s*/g, '') // Remove field: prefix
                .replace(/^\s*\{|\}\s*$/g, '') // Remove braces
                .trim();
              
              // Skip if it's a JSON keyword or too short
              if (skipKeywords.includes(text.toLowerCase()) || text.length < 3) {
                return '';
              }
              
              return text;
            })
            ?.filter((x) => x && x.length > 1) || [];
      }

      if (!Array.isArray(parsed)) parsed = [];
      // Ensure all items are strings and clean
      parsed = parsed.map(item => extractText(item)).filter(item => item.length > 0);
      setAiSuggestions({ field, items: parsed.slice(0, 5) });
    } catch (err) {
      console.error('AI suggest error:', err);
      setAiSuggestions({ field: '', items: [] });
    } finally {
      setAiLoading(false);
    }
  };

  // AI suggestions with doctor specialty context (for when user types)
  const fetchAiSuggestions = async (field, text) => {
    if (!text || text.length < 3) {
      // If no text, show mockups instead
      if (aiSuggestions.field === field) return; // Already showing mockups
      await loadFieldMockups(field);
      return;
    }
    setAiLoading(true);
    try {
      const token = user ? await user.getIdToken() : '';
      
      // Get specialty context
      const specialtyContext = doctorSpecialty.key 
        ? `in a ${isArabic ? doctorSpecialty.ar : doctorSpecialty.en} (${doctorSpecialty.key}) context`
        : 'in a medical context';
      
      // Field-specific prompts with specialty
      const fieldPrompts = {
        chiefComplaint: `Generate a professional chief complaint mockup/template based on the specialty "${isArabic ? doctorSpecialty.ar : doctorSpecialty.en}" for a patient presenting with: "${text}". Return a JSON array of 3-5 complete mockup sentences that a ${isArabic ? doctorSpecialty.ar || 'doctor' : doctorSpecialty.en || 'doctor'} would typically document.`,
        diagnosis: `Suggest professional diagnosis mockups/templates based on the specialty "${isArabic ? doctorSpecialty.ar : doctorSpecialty.en}" for: "${text}". Include ICD codes if relevant. Return a JSON array of 3-5 complete diagnosis statements that a ${isArabic ? doctorSpecialty.ar || 'doctor' : doctorSpecialty.en || 'doctor'} would typically use.`,
        findings: `Generate clinical examination findings mockup/template based on the specialty "${isArabic ? doctorSpecialty.ar : doctorSpecialty.en}" for: "${text}". Return a JSON array of 3-5 complete findings statements that a ${isArabic ? doctorSpecialty.ar || 'doctor' : doctorSpecialty.en || 'doctor'} would typically document.`,
        procedures: `Suggest medical procedures/treatments mockup/template based on the specialty "${isArabic ? doctorSpecialty.ar : doctorSpecialty.en}" for: "${text}". Include CPT codes if relevant. Return a JSON array of 3-5 complete procedure statements that a ${isArabic ? doctorSpecialty.ar || 'doctor' : doctorSpecialty.en || 'doctor'} would typically document.`,
      };
      
      const prompt = fieldPrompts[field] || `Suggest relevant ${field} terms or phrases for "${text}" ${specialtyContext}. Return a JSON array of short suggestions.`;
      
      const res = await fetch('/api/ask-shafy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(token ? { Authorization: `Bearer ${token}` } : {}),
        },
        body: JSON.stringify({
          message: prompt,
          lang: isArabic ? 'ar' : 'en',
          enable_rag: false,
          use_server_context: false,
        }),
      });

      const data = await res.json();
      const raw = data?.text || '';
      let parsed = [];

      // Helper function to extract text from JSON-like strings
      const extractText = (text) => {
        let result = String(text || '').trim();
        
        // Skip common JSON/technical keywords
        const skipKeywords = ['json', 'JSON', 'array', 'object', 'string', 'null', 'true', 'false'];
        if (skipKeywords.includes(result.toLowerCase())) {
          return '';
        }
        
        // Match patterns like: "chief_complaint": "text here" or {"field": "text"}
        // Skip if field name is a JSON keyword
        const jsonMatch1 = result.match(/["']?([\w_]+)\s*["']?\s*:\s*["']([\s\S]*?)["']/);
        if (jsonMatch1 && jsonMatch1[1] && jsonMatch1[2] && 
            !skipKeywords.includes(jsonMatch1[1].toLowerCase()) &&
            jsonMatch1[2].trim().length > 0 &&
            !skipKeywords.includes(jsonMatch1[2].trim().toLowerCase())) {
          result = jsonMatch1[2];
        }
        
        // Handle object notation: {"field": "value"} or {field: "value"}
        // Extract the actual value, skip if it's a JSON keyword
        const objMatch = result.match(/\{[\s\S]*?["']?([\w_]+)\s*["']?\s*:\s*["']([\s\S]*?)["'][\s\S]*?\}/);
        if (objMatch && objMatch[1] && objMatch[2] && 
            !skipKeywords.includes(objMatch[1].toLowerCase()) &&
            objMatch[2].trim().length > 0 &&
            !skipKeywords.includes(objMatch[2].trim().toLowerCase())) {
          result = objMatch[2];
        }
        
        // Handle patterns without quotes around the value (for Unicode text)
        const noQuotesMatch = result.match(/["']?([\w_]+)\s*["']?\s*:\s*([\s\S]+?)(?:\s*[,}]\s*|$)/);
        if (noQuotesMatch && noQuotesMatch[1] && noQuotesMatch[2] && 
            !skipKeywords.includes(noQuotesMatch[1].toLowerCase()) &&
            noQuotesMatch[2].trim().length > 5 &&
            !skipKeywords.includes(noQuotesMatch[2].trim().toLowerCase())) {
          const extracted = noQuotesMatch[2].trim().replace(/^["']|["']$/g, '');
          if (extracted.length > 0) {
            result = extracted;
          }
        }
        
        // If the result is still a JSON keyword, try to find actual content
        if (skipKeywords.includes(result.toLowerCase())) {
          // Try to extract from array notation: ["actual text", "json"]
          const arrayMatch = result.match(/\[[\s\S]*?["']([\s\S]*?)["'][\s\S]*?\]/);
          if (arrayMatch && arrayMatch[1] && !skipKeywords.includes(arrayMatch[1].trim().toLowerCase())) {
            result = arrayMatch[1];
          } else {
            return ''; // Skip if it's just a keyword
          }
        }
        
        // Remove any remaining JSON structure indicators and quotes
        result = result
          .replace(/^["'`]|["'`]$/g, '') // Remove quotes at start/end
          .replace(/^\s*["']?(json|JSON|array|object|string)\s*["']?\s*:\s*/i, '') // Remove JSON keyword prefixes
          .replace(/^\s*["']?[\w_]+\s*["']?\s*:\s*/g, '') // Remove field: prefix
          .replace(/^\s*\{|\}\s*$/g, '') // Remove braces
          .replace(/^\s*\[|\]\s*$/g, '') // Remove brackets
          .replace(/,\s*$/, '') // Remove trailing comma
          .trim();
        
        // Final check: skip if it's a JSON keyword or too short
        if (skipKeywords.includes(result.toLowerCase()) || result.length < 3) {
          return '';
        }
        
        return result;
      };

      try {
        const j = JSON.parse(raw);
        if (Array.isArray(j)) {
          parsed = j.map(item => {
            let text = '';
            if (typeof item === 'object' && item !== null) {
              // If item is an object, try to extract a string value
              const keys = Object.keys(item);
              if (keys.length > 0) {
                const firstValue = item[keys[0]];
                text = typeof firstValue === 'string' ? firstValue : JSON.stringify(item);
              } else {
                text = JSON.stringify(item);
              }
            } else {
              text = String(item || '');
            }
            return extractText(text);
          }).filter(Boolean);
        } else if (typeof j === 'object' && j !== null) {
          parsed = Object.values(j).map(item => {
            let text = '';
            if (typeof item === 'object' && item !== null) {
              text = JSON.stringify(item);
            } else {
              text = String(item || '');
            }
            return extractText(text);
          }).filter(Boolean);
        } else if (typeof j === 'string') {
          parsed = j.split(/[\n,]+/).map(x => extractText(x.trim())).filter(x => x.length > 1);
        }
      } catch {
        const skipKeywords = ['json', 'JSON', 'array', 'object', 'string', 'null', 'true', 'false'];
        parsed =
          raw
            ?.split(/[\n,]+/)
            ?.map((x) => {
              // Extract text from JSON-like strings even in catch block
              // Use improved pattern to handle Unicode/Arabic text
              let text = x.trim();
              
              // Skip if it's a JSON keyword
              if (skipKeywords.includes(text.toLowerCase())) {
                return '';
              }
              
              const jsonMatch = text.match(/["']?([\w_]+)\s*["']?\s*:\s*["']([\s\S]*?)["']/);
              if (jsonMatch && jsonMatch[1] && jsonMatch[2] && 
                  !skipKeywords.includes(jsonMatch[1].toLowerCase()) &&
                  !skipKeywords.includes(jsonMatch[2].trim().toLowerCase())) {
                text = jsonMatch[2];
              }
              
              text = text
                .replace(/^["'`]|["'`]$/g, '') // Remove quotes at start/end
                .replace(/^\s*["']?(json|JSON|array|object|string)\s*["']?\s*:\s*/i, '') // Remove JSON keyword prefixes
                .replace(/^\s*["']?[\w_]+\s*["']?\s*:\s*/g, '') // Remove field: prefix
                .replace(/^\s*\{|\}\s*$/g, '') // Remove braces
                .trim();
              
              // Skip if it's a JSON keyword or too short
              if (skipKeywords.includes(text.toLowerCase()) || text.length < 3) {
                return '';
              }
              
              return text;
            })
            ?.filter((x) => x && x.length > 1) || [];
      }

      if (!Array.isArray(parsed)) parsed = [];
      // Ensure all items are strings and clean
      parsed = parsed.map(item => extractText(item)).filter(item => item.length > 0);
      setAiSuggestions({ field, items: parsed.slice(0, 5) });
    } catch (err) {
      console.error('AI suggest error:', err);
      setAiSuggestions({ field: '', items: [] });
    } finally {
      setAiLoading(false);
    }
  };

  const insertSuggestion = (field, val) => {
    // Helper function to extract text from JSON-like strings
    const extractText = (text) => {
      let result = String(text || '').trim();
      
      // Match patterns like: "chief_complaint": "text here" or {"field": "text"}
      // Use [\s\S]*? to match any character including Unicode/Arabic (non-greedy)
      const jsonMatch1 = result.match(/["']?[\w_]+\s*["']?\s*:\s*["']([\s\S]*?)["']/);
      if (jsonMatch1 && jsonMatch1[1] && jsonMatch1[1].trim().length > 0) {
        result = jsonMatch1[1];
      }
      
      // Handle object notation: {"field": "value"} or {field: "value"}
      const objMatch = result.match(/\{[\s\S]*?["']?[\w_]+\s*["']?\s*:\s*["']([\s\S]*?)["'][\s\S]*?\}/);
      if (objMatch && objMatch[1] && objMatch[1].trim().length > 0) {
        result = objMatch[1];
      }
      
      // Handle patterns without quotes around the value (for Unicode text)
      const noQuotesMatch = result.match(/["']?[\w_]+\s*["']?\s*:\s*([\s\S]+?)(?:\s*[,}]\s*|$)/);
      if (noQuotesMatch && noQuotesMatch[1] && noQuotesMatch[1].trim().length > 5) {
        const extracted = noQuotesMatch[1].trim().replace(/^["']|["']$/g, '');
        if (extracted.length > 0) {
          result = extracted;
        }
      }
      
      // Remove any remaining JSON structure indicators and quotes
      result = result
        .replace(/^["'`]|["'`]$/g, '') // Remove quotes at start/end
        .replace(/^\s*["']?[\w_]+\s*["']?\s*:\s*/g, '') // Remove field: prefix
        .replace(/^\s*\{|\}\s*$/g, '') // Remove braces
        .replace(/^\s*\[|\]\s*$/g, '') // Remove brackets
        .replace(/,\s*$/, '') // Remove trailing comma
        .trim();
      
      return result;
    };
    
    // Ensure val is a string and clean it from JSON-like structures
    let stringVal = val;
    if (typeof val === 'object' && val !== null) {
      const keys = Object.keys(val);
      if (keys.length > 0) {
        const firstValue = val[keys[0]];
        stringVal = typeof firstValue === 'string' ? firstValue : JSON.stringify(val);
      } else {
        stringVal = JSON.stringify(val);
      }
    } else {
      stringVal = String(val || '');
    }
    
    stringVal = extractText(stringVal);
    
    setForm((prev) => ({ ...prev, [field]: stringVal }));
    setAiSuggestions({ field: '', items: [] });
  };

  // Attachment handlers
  const handleFilePick = async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    if (!f.type?.startsWith('image/')) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Only image files are supported.', 'الصور فقط مدعومة.'),
      });
      return;
    }

    if (previewURL) URL.revokeObjectURL(previewURL);
    setPreviewURL(URL.createObjectURL(f));
    setFileName(f.name);

    setAttaching(true);
    try {
      const hosted = await uploadImageToImgbb(f);
      setImgbbURL(hosted);
      setSnack({
        open: true,
        severity: 'success',
        msg: t('Image uploaded successfully.', 'تم رفع الصورة بنجاح.'),
      });
    } catch (err) {
      console.error(err);
      setImgbbURL('');
      setSnack({
        open: true,
        severity: 'error',
        msg: err?.message || t('Failed to upload image.', 'فشل رفع الصورة.'),
      });
    } finally {
      setAttaching(false);
    }
  };

  const clearFile = () => {
    if (previewURL) URL.revokeObjectURL(previewURL);
    setPreviewURL('');
    setFileName('');
    setImgbbURL('');
  };

  // Vitals handlers
  const handleVitalsChange = (field) => (e) => {
    setForm((prev) => ({
      ...prev,
      [`vitals${field.toUpperCase()}`]: e.target.value,
    }));
  };

  const availableVitalsFields = [
    { key: 'weight', label: t('Weight', 'الوزن'), unit: 'kg' },
    { key: 'height', label: t('Height', 'الطول'), unit: 'cm' },
    { key: 'bmi', label: t('BMI', 'مؤشر كتلة الجسم') },
    { key: 'sugar', label: t('Blood Sugar', 'سكر الدم'), unit: 'mg/dL' },
    { key: 'resp', label: t('Respiratory Pattern', 'نمط التنفس') },
    { key: 'pain', label: t('Pain Level', 'مستوى الألم') },
  ];

  const handleAddVitalField = () => {
    if (selectedVitalField === 'custom' && customVitalField.trim()) {
      setExtraVitalsFields((prev) => [
        ...prev,
        { key: customVitalField.toLowerCase().replace(/\s+/g, ''), label: customVitalField, custom: true },
      ]);
    } else {
      const field = availableVitalsFields.find((f) => f.key === selectedVitalField);
      if (field && !extraVitalsFields.some((ef) => ef.key === field.key)) {
        setExtraVitalsFields((prev) => [...prev, field]);
      }
    }
    setVitalsDialogOpen(false);
    setSelectedVitalField('');
    setCustomVitalField('');
  };

  // Auto BMI
  React.useEffect(() => {
    const weight = parseFloat(form.vitalsWEIGHT);
    const height = parseFloat(form.vitalsHEIGHT);
    if (weight && height) {
      const bmi = (weight / ((height / 100) ** 2)).toFixed(1);
      setForm((prev) => ({ ...prev, vitalsBMI: bmi }));
    }
  }, [form.vitalsWEIGHT, form.vitalsHEIGHT]);

  // Auto-generate title with AI after filling all fields
  const autoGenerateTitle = React.useCallback(async () => {
    // Check if main clinical fields are filled (all important fields must have data)
    const hasAllMainData = 
      (form.diagnosis?.trim() || form.chiefComplaint?.trim() || form.findings?.trim()) &&
      (medicationsList.some((m) => m.name?.trim()) || testsList.some((t) => t.name?.trim()) || form.procedures?.trim());

    // Only generate if all main fields are filled
    if (!hasAllMainData) return;

    // Don't regenerate if titles are already generated (user might have edited them)
    // Once generated, never regenerate automatically
    if (titleAutoGenerated.ar && titleAutoGenerated.en) return;

    // If titles exist but weren't auto-generated, mark them as generated to prevent regeneration
    if (form.titleAr?.trim() && form.titleEn?.trim() && !titleAutoGenerated.ar && !titleAutoGenerated.en) {
      // User might have manually entered titles, mark as generated to prevent auto-generation
      setTitleAutoGenerated({ ar: true, en: true });
      return;
    }

    setTitleGenerating(true);

    try {
      const token = user ? await user.getIdToken() : '';
      const specialtyName = doctorSpecialty.key 
        ? (isArabic ? doctorSpecialty.ar : doctorSpecialty.en)
        : 'medical';
      
      const dataSummary = [
        form.diagnosis && `التشخيص / Diagnosis: ${form.diagnosis}`,
        form.chiefComplaint && `الشكوى الرئيسية / Chief Complaint: ${form.chiefComplaint}`,
        form.findings && `النتائج / Findings: ${form.findings.substring(0, 150)}`,
        form.procedures && `الإجراءات / Procedures: ${form.procedures.substring(0, 150)}`,
        medicationsList.filter((m) => m.name?.trim()).length > 0 && `الأدوية / Medications: ${medicationsList.filter((m) => m.name?.trim()).map(m => m.name).join(', ')}`,
        testsList.filter((t) => t.name?.trim()).length > 0 && `الفحوصات / Tests: ${testsList.filter((t) => t.name?.trim()).map(t => t.name).join(', ')}`,
      ].filter(Boolean).join('\n\n');

      if (!dataSummary) {
        setTitleGenerating(false);
        return;
      }

      // Generate both Arabic and English titles in parallel
      const generateTitle = async (lang, isAr) => {
        // Only generate if title is empty
        if (isAr && form.titleAr?.trim()) return form.titleAr;
        if (!isAr && form.titleEn?.trim()) return form.titleEn;

        try {
      const res = await fetch('/api/ask-shafy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(token ? { Authorization: `Bearer ${token}` } : {}),
        },
        body: JSON.stringify({
              message: `Based on this medical report data for a ${specialtyName} specialist, generate a concise, professional medical report title in ${lang} (maximum 60 characters, no quotes, no explanation):\n\n${dataSummary}\n\nReturn only the title text.`,
              lang: isAr ? 'ar' : 'en',
          enable_rag: false,
          use_server_context: false,
        }),
      });

      const data = await res.json();
          const title = (data?.text || '').trim()
            .replace(/^["']+|["']+$/g, '') // Remove surrounding quotes
            .replace(/["']/g, '') // Remove any remaining quotes
            .replace(/\n.*$/g, '') // Remove newlines and everything after
            .substring(0, 60)
            .trim();
          
          return title || '';
        } catch (err) {
          console.error(`Error generating ${lang} title:`, err);
          return '';
        }
      };

      // Generate both titles in parallel
      const [titleAr, titleEn] = await Promise.all([
        !form.titleAr?.trim() ? generateTitle('Arabic', true) : Promise.resolve(form.titleAr || ''),
        !form.titleEn?.trim() ? generateTitle('English', false) : Promise.resolve(form.titleEn || ''),
      ]);

      // Update form with generated titles
      if (titleAr && !form.titleAr?.trim()) {
        setForm((prev) => ({ ...prev, titleAr }));
        setTitleAutoGenerated((prev) => ({ ...prev, ar: true }));
      }
      if (titleEn && !form.titleEn?.trim()) {
        setForm((prev) => ({ ...prev, titleEn }));
        setTitleAutoGenerated((prev) => ({ ...prev, en: true }));
      }
    } catch (err) {
      console.error('AI title generation error:', err);
    } finally {
      setTitleGenerating(false);
    }
  }, [
    form.diagnosis, 
    form.findings, 
    form.procedures, 
    form.chiefComplaint,
    form.titleAr,
    form.titleEn,
    medicationsList, 
    testsList, 
    isArabic, 
    user,
    doctorSpecialty,
    titleAutoGenerated
  ]);

  // Auto-generate title when all fields are filled
  React.useEffect(() => {
    const timer = setTimeout(() => {
      autoGenerateTitle();
    }, 2000);
    return () => clearTimeout(timer);
  }, [autoGenerateTitle]);

  // Save prescription
  const handleSave = async () => {
    if (!selectedPatient) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Please select a patient.', 'يرجى اختيار المريض.'),
      });
      return;
    }

    // Check if at least one field has data
    const hasAnyData = 
      form.titleAr?.trim() ||
      form.titleEn?.trim() ||
      form.diagnosis?.trim() ||
      form.findings?.trim() ||
      form.procedures?.trim() ||
      form.chiefComplaint?.trim() ||
      form.vitalsBP?.trim() ||
      form.vitalsHR?.trim() ||
      form.vitalsTemp?.trim() ||
      form.vitalsSpO2?.trim() ||
      extraVitalsFields.some((f) => form[`vitals${f.key.toUpperCase()}`]?.trim()) ||
      medicationsList.some((m) => m.name?.trim()) ||
      testsList.some((t) => t.name?.trim()) ||
      imgbbURL?.trim();

    if (!hasAnyData) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Please fill at least one field.', 'يرجى ملء حقل واحد على الأقل.'),
      });
      return;
    }

    setSubmitting(true);
    try {
      // Filter valid medications and tests (keep all entered data)
      const validMedications = medicationsList.filter((m) => m.name?.trim());
      const validTests = testsList.filter((t) => t.name?.trim());

      // Prepare all data
      const allData = {
        ...form,
        medicationsList: validMedications,
        testsList: validTests,
        imgbbURL,
        extraVitalsFields: extraVitalsFields.map((f) => ({
          key: f.key,
          label: f.label,
          value: form[`vitals${f.key.toUpperCase()}`] || '',
        })),
      };

      // Save to reports collection (for reports list)
      await addDoc(collection(db, 'reports'), {
        type: 'clinical',
        patientID: selectedPatient.id,
        patientName: selectedPatient.name,
        ...allData,
        createdAt: serverTimestamp(),
        createdBy: user.uid,
        appointmentId: router.query.appointmentId || null,
      });

      // Save to patient profile (all data)
      const patientRef = doc(db, 'patients', selectedPatient.id);
      const prescriptionData = {
        ...allData,
        createdAt: serverTimestamp(),
        createdBy: user.uid,
        appointmentId: router.query.appointmentId || null,
      };

      // Add to prescriptions array in patient profile
      await updateDoc(patientRef, {
        prescriptions: arrayUnion(prescriptionData),
        updatedAt: serverTimestamp(),
      });

      setSnack({
        open: true,
        severity: 'success',
        msg: t('Prescription saved successfully!', 'تم حفظ الوصفة بنجاح!'),
      });

      // Reset form
      setSelectedPatient(null);
      setPatientInfo({ mrn: '', sex: '', dobStr: '', phone: '' });
      setForm({
        titleAr: '',
        titleEn: '',
        dateStr: '',
        diagnosis: '',
        findings: '',
        procedures: '',
        chiefComplaint: '',
        vitalsBP: '',
        vitalsHR: '',
        vitalsTemp: '',
        vitalsSpO2: '',
      });
      setPreviewURL('');
      setFileName('');
      setImgbbURL('');
      setExtraVitalsFields([]);
      setMedicationsList([{ name: '', dose: '', frequency: '', duration: '', notes: '' }]);
      setTestsList([{ name: '', notes: '' }]);
      setTitleAutoGenerated({ ar: false, en: false });
      setTitleGenerating(false);

      // Redirect after a short delay
      setTimeout(() => {
        router.push(`/patient-reports${isArabic ? '?lang=ar' : ''}`);
      }, 1500);
    } catch (err) {
      console.error(err);
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Failed to save prescription.', 'فشل حفظ الوصفة.'),
      });
    } finally {
      setSubmitting(false);
    }
  };

  // Share prescription via WhatsApp
  const handleWhatsAppShare = () => {
    if (!selectedPatient) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Please select a patient first.', 'يرجى اختيار المريض أولاً.'),
      });
      return;
    }

    const hasMedications = medicationsList.some((m) => m.name?.trim());
    const hasTests = testsList.some((t) => t.name?.trim());

    if (!hasMedications && !hasTests) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Please add at least one medication or test.', 'يرجى إضافة دواء أو فحص واحد على الأقل.'),
      });
      return;
    }

    const patientPhone = patientInfo.phone || selectedPatient.phone || '';
    if (!patientPhone) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Patient phone number is required for WhatsApp sharing.', 'رقم هاتف المريض مطلوب للمشاركة عبر واتساب.'),
      });
      return;
    }

    // Format phone number (remove non-digits, ensure Egyptian format with +20)
    const phoneRaw = String(patientPhone || '').replace(/\D/g, '');
    if (!phoneRaw) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Invalid phone number.', 'رقم الهاتف غير صحيح.'),
      });
      return;
    }
    
    // Always treat as Egyptian number: +20 (Egypt country code for WhatsApp)
    // Remove leading zeros and ensure it starts with +20
    let phoneDigits = phoneRaw.replace(/^0+/, '');
    let formattedPhone;
    
    if (phoneDigits.startsWith('20')) {
      // Already starts with 20
      formattedPhone = `+${phoneDigits}`;
    } else {
      // Add +20 (Egypt country code for WhatsApp)
      formattedPhone = `+20${phoneDigits}`;
    }

    // Build prescription message
    const patientName = selectedPatient.name || selectedPatient.id || t('Patient', 'المريض');
    const today = new Date().toLocaleDateString(isArabic ? 'ar-EG' : 'en-US');
    
    const messageLines = [
      isArabic ? '📋 وصفة طبية' : '📋 Medical Prescription',
      '',
      `${isArabic ? 'اسم المريض' : 'Patient Name'}: ${patientName}`,
      `${isArabic ? 'التاريخ' : 'Date'}: ${today}`,
      '',
    ];

    // Add medications
    const medications = medicationsList.filter((m) => m.name?.trim());
    if (medications.length > 0) {
      messageLines.push(isArabic ? '💊 الأدوية:' : '💊 Medications:');
      medications.forEach((m) => {
        const medLine = `• ${m.name || ''}`;
        const details = [];
        if (m.dose) details.push(`${isArabic ? 'الجرعة' : 'Dose'}: ${m.dose}`);
        if (m.frequency) details.push(`${isArabic ? 'التكرار' : 'Frequency'}: ${m.frequency}`);
        if (m.duration) details.push(`${isArabic ? 'المدة' : 'Duration'}: ${m.duration}`);
        if (m.notes) details.push(m.notes);
        messageLines.push(medLine + (details.length > 0 ? ` (${details.join(', ')})` : ''));
      });
      messageLines.push('');
    }

    // Add tests
    const tests = testsList.filter((t) => t.name?.trim());
    if (tests.length > 0) {
      messageLines.push(isArabic ? '🔬 الفحوصات المطلوبة:' : '🔬 Required Tests:');
      tests.forEach((t) => {
        const testLine = `• ${t.name || ''}`;
        if (t.notes) {
          messageLines.push(`${testLine} - ${t.notes}`);
        } else {
          messageLines.push(testLine);
        }
      });
    }

    const message = messageLines.join('\n');
    const waUrl = `https://wa.me/${formattedPhone}?text=${encodeURIComponent(message)}`;
    window.open(waUrl, '_blank', 'noopener,noreferrer');
  };

  // Print prescription
  const handlePrint = () => {
    if (!selectedPatient) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Please select a patient first.', 'يرجى اختيار المريض أولاً.'),
      });
      return;
    }

    const hasMedications = medicationsList.some((m) => m.name?.trim());
    const hasTests = testsList.some((t) => t.name?.trim());

    if (!hasMedications && !hasTests) {
      setSnack({
        open: true,
        severity: 'error',
        msg: t('Please add at least one medication or test.', 'يرجى إضافة دواء أو فحص واحد على الأقل.'),
      });
      return;
    }

    // Create print window
    const printWindow = window.open('', '_blank', 'width=600,height=800');
    if (!printWindow) {
      setSnack({
        open: true,
        severity: 'warning',
        msg: t('Please enable popups to print.', 'يرجى تفعيل النوافذ المنبثقة للطباعة.'),
      });
      return;
    }

    const doctorName = user?.displayName || user?.email || '';
    const today = new Date().toLocaleDateString(isArabic ? 'ar-EG' : 'en-US');

    const medicationsHtml = medicationsList
      .filter((m) => m.name?.trim())
      .map(
        (m) => `
      <tr>
        <td style="padding: 8px; border-bottom: 1px solid #eee;">${m.name || ''}</td>
        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${m.dose || ''}</td>
        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${m.frequency || ''}</td>
        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${m.duration || ''}</td>
        <td style="padding: 8px; border-bottom: 1px solid #eee;">${m.notes || ''}</td>
      </tr>
    `
      )
      .join('');

    const testsHtml = testsList
      .filter((t) => t.name?.trim())
      .map(
        (t) => `
      <tr>
        <td style="padding: 8px; border-bottom: 1px solid #eee;">${t.name || ''}</td>
        <td style="padding: 8px; border-bottom: 1px solid #eee;">${t.notes || ''}</td>
      </tr>
    `
      )
      .join('');

    const html = `
      <!DOCTYPE html>
      <html dir="${dir}" lang="${isArabic ? 'ar' : 'en'}">
      <head>
        <meta charset="UTF-8">
        <title>${t('Prescription', 'وصفة طبية')}</title>
        <style>
          @page {
            size: 165mm 250mm;
            margin: 15mm;
          }
          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }
          body {
            font-family: 'Arial', 'Tahoma', sans-serif;
            font-size: 12px;
            line-height: 1.6;
            color: #000;
            padding: 20px;
            direction: ${dir};
            text-align: ${isArabic ? 'right' : 'left'};
          }
          .header {
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
            margin-bottom: 15px;
          }
          .header h1 {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
          }
          .patient-info {
            margin-bottom: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
          }
          .patient-info p {
            margin: 3px 0;
            font-size: 11px;
          }
          .section {
            margin-bottom: 20px;
          }
          .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #ccc;
          }
          table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
          }
          table th {
            background: #f0f0f0;
            padding: 8px;
            text-align: ${isArabic ? 'right' : 'left'};
            font-weight: bold;
            font-size: 11px;
            border: 1px solid #ddd;
          }
          table td {
            padding: 8px;
            border: 1px solid #ddd;
            font-size: 11px;
          }
          .footer {
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid #ccc;
            text-align: ${isArabic ? 'right' : 'left'};
            font-size: 10px;
          }
          .signature {
            margin-top: 30px;
            text-align: ${isArabic ? 'right' : 'left'};
          }
          @media print {
            body {
              padding: 0;
            }
            .no-print {
              display: none;
            }
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>${t('Medical Prescription', 'وصفة طبية')}</h1>
        </div>

        <div class="patient-info">
          <p><strong>${t('Patient Name', 'اسم المريض')}:</strong> ${selectedPatient.name}</p>
          ${patientInfo.mrn ? `<p><strong>${t('MRN', 'رقم الملف')}:</strong> ${patientInfo.mrn}</p>` : ''}
          ${patientInfo.phone ? `<p><strong>${t('Phone', 'الهاتف')}:</strong> ${patientInfo.phone}</p>` : ''}
          <p><strong>${t('Date', 'التاريخ')}:</strong> ${today}</p>
        </div>

        ${medicationsHtml ? `
        <div class="section">
          <div class="section-title">${t('Medications', 'الأدوية')}</div>
          <table>
            <thead>
              <tr>
                <th>${t('Medicine', 'الدواء')}</th>
                <th style="text-align: center;">${t('Dose', 'الجرعة')}</th>
                <th style="text-align: center;">${t('Frequency', 'التكرار')}</th>
                <th style="text-align: center;">${t('Duration', 'المدة')}</th>
                <th>${t('Notes', 'ملاحظات')}</th>
              </tr>
            </thead>
            <tbody>
              ${medicationsHtml}
            </tbody>
          </table>
        </div>
        ` : ''}

        ${testsHtml ? `
        <div class="section">
          <div class="section-title">${t('Medical Tests', 'الفحوصات الطبية')}</div>
          <table>
            <thead>
              <tr>
                <th>${t('Test Name', 'اسم الفحص')}</th>
                <th>${t('Notes / Instructions', 'ملاحظات / تعليمات')}</th>
              </tr>
            </thead>
            <tbody>
              ${testsHtml}
            </tbody>
          </table>
        </div>
        ` : ''}

        <div class="footer">
          <div class="signature">
            <p><strong>${t('Doctor', 'الطبيب')}:</strong> ${doctorName}</p>
          </div>
        </div>
      </body>
      </html>
    `;

    printWindow.document.write(html);
    printWindow.document.close();
    printWindow.focus();

    // Wait for content to load, then print
    setTimeout(() => {
      printWindow.print();
    }, 250);
  };

  return (
    <Protected>
      <AppLayout>
        <Box 
          dir={dir} 
          sx={{ 
            minHeight: '100vh', 
            pb: 4,
            background: 'linear-gradient(135deg, rgba(25, 118, 210, 0.02) 0%, rgba(66, 165, 245, 0.01) 50%, rgba(156, 39, 176, 0.02) 100%)',
            position: 'relative',
            '&::before': {
              content: '""',
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'radial-gradient(circle at 20% 50%, rgba(25, 118, 210, 0.05) 0%, transparent 50%), radial-gradient(circle at 80% 80%, rgba(66, 165, 245, 0.04) 0%, transparent 50%), radial-gradient(circle at 40% 20%, rgba(156, 39, 176, 0.03) 0%, transparent 50%)',
              pointerEvents: 'none',
              zIndex: 0,
            },
          }}
        >
          <Container maxWidth="md" sx={{ py: 2, position: 'relative', zIndex: 1 }}>
            {/* Header */}
            <Paper
              elevation={0}
              sx={{
                p: 3,
                mb: 3,
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.98) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.08), 0 2px 8px rgba(0,0,0,0.04)',
                position: 'relative',
                overflow: 'hidden',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  height: '4px',
                  background: 'linear-gradient(90deg, #1976d2 0%, #42a5f5 50%, #9c27b0 100%)',
                  backgroundSize: '200% 100%',
                  animation: 'shimmer 3s ease-in-out infinite',
                },
                '@keyframes shimmer': {
                  '0%': { backgroundPosition: '200% 0' },
                  '100%': { backgroundPosition: '-200% 0' },
                },
              }}
            >
              <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 2 }}>
                <Button
                  component={Link}
                  href={`/patient-reports${isArabic ? '?lang=ar' : ''}`}
                  startIcon={isArabic ? null : <ArrowBackIcon />}
                  endIcon={isArabic ? <ArrowBackIcon /> : null}
                  sx={{
                    borderRadius: 2.5,
                    textTransform: 'none',
                    fontWeight: 700,
                    px: 2.5,
                    borderWidth: 2,
                    '&:hover': {
                      borderWidth: 2,
                      transform: 'translateY(-2px)',
                      boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
                    },
                    transition: 'all 0.2s ease',
                  }}
                >
                  {t('Back', 'رجوع')}
                </Button>
                <Stack direction="row" spacing={1.5}>
                  <Button
                    variant="contained"
                    startIcon={<WhatsAppIcon />}
                    onClick={handleWhatsAppShare}
                    sx={{
                      minWidth: 140,
                      borderRadius: 2.5,
                      textTransform: 'none',
                      fontWeight: 700,
                      background: 'linear-gradient(135deg, #25D366 0%, #128C7E 100%)',
                      boxShadow: '0 4px 12px rgba(37, 211, 102, 0.3)',
                      '&:hover': {
                        background: 'linear-gradient(135deg, #20BA5A 0%, #0E7A6E 100%)',
                        boxShadow: '0 6px 16px rgba(37, 211, 102, 0.4)',
                        transform: 'translateY(-2px)',
                      },
                      transition: 'all 0.2s ease',
                    }}
                  >
                    {t('Share via WhatsApp', 'مشاركة عبر واتساب')}
                  </Button>
                  <Button
                    variant="contained"
                    startIcon={<PrintIcon />}
                    onClick={handlePrint}
                    sx={{
                      minWidth: 120,
                      borderRadius: 2.5,
                      textTransform: 'none',
                      fontWeight: 700,
                      background: 'linear-gradient(135deg, #1976d2 0%, #42a5f5 100%)',
                      boxShadow: '0 4px 12px rgba(25, 118, 210, 0.3)',
                      '&:hover': {
                        background: 'linear-gradient(135deg, #1565c0 0%, #1976d2 100%)',
                        boxShadow: '0 6px 16px rgba(25, 118, 210, 0.4)',
                        transform: 'translateY(-2px)',
                      },
                      transition: 'all 0.2s ease',
                    }}
                  >
                    {t('Print', 'طباعة')}
                  </Button>
                </Stack>
              </Stack>

              <Typography 
                variant="h4" 
                fontWeight={900} 
                sx={{ 
                  mb: 1,
                  background: 'linear-gradient(135deg, #1976d2 0%, #42a5f5 50%, #9c27b0 100%)',
                  backgroundClip: 'text',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                }}
              >
                {t('New Prescription', 'وصفة طبية جديدة')}
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 0 }}>
                {t('Create a medical prescription with medications and tests.', 'إنشاء وصفة طبية تحتوي على الأدوية والفحوصات.')}
              </Typography>
            </Paper>

            {/* Patient Selection */}
            <Paper 
              elevation={0}
              sx={{ 
                p: 3.5, 
                mb: 3, 
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.95) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04)',
                transition: 'all 0.3s ease',
                '&:hover': {
                  boxShadow: '0 12px 40px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.06)',
                  transform: 'translateY(-2px)',
                },
                position: 'relative',
                overflow: 'hidden',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '5px',
                  height: '100%',
                  background: 'linear-gradient(180deg, #1976d2 0%, #42a5f5 50%, #64b5f6 100%)',
                  transition: 'all 0.3s ease',
                },
              }}
            >
              <Stack direction="row" alignItems="center" spacing={1.5} sx={{ mb: 2.5 }}>
                <Box
                  sx={{
                    width: 48,
                    height: 48,
                    borderRadius: 3,
                    background: 'linear-gradient(135deg, #1976d2 0%, #42a5f5 100%)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: '0 4px 16px rgba(25, 118, 210, 0.3)',
                  }}
                >
                  <PersonIcon sx={{ color: 'white', fontSize: 24 }} />
                </Box>
                <Typography 
                  variant="h6" 
                  fontWeight={800}
                  sx={{
                    background: 'linear-gradient(135deg, #1976d2 0%, #42a5f5 100%)',
                    backgroundClip: 'text',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                  }}
                >
                  {t('Patient Information', 'معلومات المريض')}
                </Typography>
              </Stack>

              <Autocomplete
                options={patients}
                loading={patientsLoading}
                value={selectedPatient}
                onChange={async (_, value) => {
                  setSelectedPatient(value);
                  await fetchPatientInfo(value?.id);
                }}
                getOptionLabel={(opt) => opt?.name || ''}
                isOptionEqualToValue={(opt, val) => opt.id === val.id}
                noOptionsText={t('No patients found', 'لا يوجد مرضى')}
                filterOptions={(options, { inputValue }) => {
                  if (!inputValue) return options;
                  const q = inputValue.toLowerCase();
                  return options.filter((opt) => {
                    const name = (opt.name || '').toLowerCase();
                    const phone = (opt.phone || '').toLowerCase();
                    return name.includes(q) || phone.includes(q);
                  });
                }}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label={t('Select Patient', 'اختر المريض')}
                    placeholder={t('Search by name or phone', 'ابحث بالاسم أو الهاتف')}
                    InputProps={{
                      ...params.InputProps,
                      endAdornment: (
                        <>
                          {patientsLoading && <CircularProgress size={18} />}
                          {params.InputProps.endAdornment}
                        </>
                      ),
                    }}
                  />
                )}
              />

              {selectedPatient && (
                <Grid container spacing={2} sx={{ mt: 2 }}>
                  {[
                    { label: t('MRN', 'رقم الملف'), value: patientInfo.mrn },
                    { label: t('Sex', 'النوع'), value: patientInfo.sex },
                    { label: t('DOB', 'تاريخ الميلاد'), value: patientInfo.dobStr },
                    { label: t('Phone', 'الهاتف'), value: patientInfo.phone },
                  ].map((item, idx) => (
                    <Grid item xs={6} sm={3} key={idx}>
                      <Paper
                        elevation={0}
                        sx={{
                          p: 1.5,
                          borderRadius: 2,
                          background: 'linear-gradient(135deg, rgba(25, 118, 210, 0.05) 0%, rgba(66, 165, 245, 0.03) 100%)',
                          border: '1px solid',
                          borderColor: 'rgba(25, 118, 210, 0.1)',
                          transition: 'all 0.2s ease',
                          '&:hover': {
                            background: 'linear-gradient(135deg, rgba(25, 118, 210, 0.08) 0%, rgba(66, 165, 245, 0.05) 100%)',
                            borderColor: 'rgba(25, 118, 210, 0.2)',
                            transform: 'translateY(-2px)',
                          },
                        }}
                      >
                        <Typography variant="caption" color="text.secondary" fontWeight={600}>
                          {item.label}
                        </Typography>
                        <Typography variant="body2" fontWeight={700} color="primary.main">
                          {item.value || '-'}
                        </Typography>
                      </Paper>
                    </Grid>
                  ))}
                </Grid>
              )}
            </Paper>

            {/* Attachment Section */}
            <Paper 
              elevation={0}
              sx={{ 
                p: 3.5, 
                mb: 3, 
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.95) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04)',
                transition: 'all 0.3s ease',
                '&:hover': {
                  boxShadow: '0 12px 40px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.06)',
                  transform: 'translateY(-2px)',
                },
                position: 'relative',
                overflow: 'hidden',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '5px',
                  height: '100%',
                  background: 'linear-gradient(180deg, #9c27b0 0%, #ba68c8 50%, #ce93d8 100%)',
                  transition: 'all 0.3s ease',
                },
              }}
            >
              <Stack direction="row" alignItems="center" spacing={1.5} sx={{ mb: 2.5 }}>
                <Box
                  sx={{
                    width: 48,
                    height: 48,
                    borderRadius: 3,
                    background: 'linear-gradient(135deg, #9c27b0 0%, #ba68c8 100%)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: '0 4px 16px rgba(156, 39, 176, 0.3)',
                  }}
                >
                  <NoteAltIcon sx={{ color: 'white', fontSize: 24 }} />
                </Box>
                <Typography 
                  variant="h6" 
                  fontWeight={800}
                  sx={{
                    background: 'linear-gradient(135deg, #9c27b0 0%, #ba68c8 100%)',
                    backgroundClip: 'text',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                  }}
                >
                  {t('Attachment', 'المرفق')}
                </Typography>
              </Stack>
              <Stack spacing={2}>
                <Stack direction="row" spacing={1.5} alignItems="center" flexWrap="wrap">
                  <Tooltip title={t('Attach report image', 'إرفاق صورة التقرير')}>
                    <Button 
                      variant="outlined" 
                      startIcon={<AddPhotoAlternateIcon />} 
                      component="label"
                      sx={{
                        borderRadius: 2.5,
                        textTransform: 'none',
                        fontWeight: 700,
                        px: 2.5,
                        borderWidth: 2,
                        borderColor: 'secondary.main',
                        color: 'secondary.main',
                        '&:hover': {
                          borderWidth: 2,
                          borderColor: 'secondary.dark',
                          background: 'rgba(156, 39, 176, 0.08)',
                          transform: 'translateY(-2px)',
                          boxShadow: '0 4px 12px rgba(156, 39, 176, 0.2)',
                        },
                        transition: 'all 0.2s ease',
                      }}
                    >
                      {t('Attach Image', 'إرفاق صورة')}
                      <input type="file" hidden accept="image/*" onChange={handleFilePick} />
                    </Button>
                  </Tooltip>
                  {fileName && (
                    <Typography variant="body2" color="text.secondary" noWrap sx={{ maxWidth: 240 }}>
                      {fileName}
                    </Typography>
                  )}
                  {previewURL && (
                    <Button color="error" size="small" onClick={clearFile}>
                      {t('Remove', 'إزالة')}
                    </Button>
                  )}
                </Stack>
                {attaching && (
                  <Stack sx={{ minWidth: 220 }}>
                    <Typography variant="caption" color="text.secondary">
                      {t('Uploading image…', 'جاري رفع الصورة…')}
                    </Typography>
                    <LinearProgress />
                  </Stack>
                )}
                {!!previewURL && (
                  <Box
                    sx={{
                      mt: 1.5,
                      width: '100%',
                      borderRadius: 2,
                      border: (t2) => `1px solid ${t2.palette.divider}`,
                      overflow: 'hidden',
                    }}
                  >
                    <Box
                      sx={{
                        aspectRatio: '16 / 9',
                        backgroundImage: `url(${previewURL})`,
                        backgroundSize: 'cover',
                        backgroundPosition: 'center',
                      }}
                    />
                  </Box>
                )}
              </Stack>
            </Paper>

            {/* Meta Section */}
            <Paper 
              elevation={0}
              sx={{ 
                p: 3.5, 
                mb: 3, 
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.95) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04)',
                transition: 'all 0.3s ease',
                '&:hover': {
                  boxShadow: '0 12px 40px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.06)',
                  transform: 'translateY(-2px)',
                },
                position: 'relative',
                overflow: 'hidden',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '5px',
                  height: '100%',
                  background: 'linear-gradient(180deg, #ff9800 0%, #ffb74d 50%, #ffcc80 100%)',
                  transition: 'all 0.3s ease',
                },
              }}
            >
              <Stack direction="row" alignItems="center" spacing={1.5} sx={{ mb: 2.5 }}>
                <Box
                  sx={{
                    width: 48,
                    height: 48,
                    borderRadius: 3,
                    background: 'linear-gradient(135deg, #ff9800 0%, #ffb74d 100%)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: '0 4px 16px rgba(255, 152, 0, 0.3)',
                  }}
                >
                  <EventIcon sx={{ color: 'white', fontSize: 24 }} />
                </Box>
                <Typography 
                  variant="h6" 
                  fontWeight={800}
                  sx={{
                    background: 'linear-gradient(135deg, #ff9800 0%, #ffb74d 100%)',
                    backgroundClip: 'text',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                  }}
                >
                  {t('Report Meta', 'بيانات التقرير')}
                </Typography>
              </Stack>
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                  {titleGenerating && !titleAutoGenerated.ar && (
                    <Box sx={{ mb: 1, display: 'flex', alignItems: 'center', gap: 1 }}>
                      <CircularProgress size={16} sx={{ color: '#8a4baf' }} />
                      <Typography variant="caption" color="text.secondary">
                        {t('Generating title...', 'جارٍ توليد العنوان...')}
                      </Typography>
                    </Box>
                  )}
                  <TextField
                    label={t('Title (Arabic)', 'العنوان (عربي)')}
                    fullWidth
                    value={form.titleAr}
                    onChange={handleFormChange('titleAr')}
                    disabled={!titleAutoGenerated.ar}
                    helperText={
                      !titleAutoGenerated.ar
                        ? t('Title will be generated automatically after filling all fields', 'سيتم توليد العنوان تلقائياً بعد ملء كافة الخانات')
                        : titleAutoGenerated.ar && form.titleAr?.trim()
                        ? t('Auto-generated - you can edit', 'مولّد تلقائياً - يمكنك التعديل')
                        : ' '
                    }
                    InputProps={{
                      endAdornment: titleAutoGenerated.ar && form.titleAr?.trim() && (
                        <InputAdornment position="end">
                          <Tooltip title={t('Auto-generated', 'مولّد تلقائياً')}>
                            <AutoAwesomeIcon fontSize="small" sx={{ color: '#8a4baf' }} />
                          </Tooltip>
                        </InputAdornment>
                      ),
                    }}
                    inputProps={{ maxLength: 80 }}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  {titleGenerating && !titleAutoGenerated.en && (
                    <Box sx={{ mb: 1, display: 'flex', alignItems: 'center', gap: 1 }}>
                      <CircularProgress size={16} sx={{ color: '#8a4baf' }} />
                      <Typography variant="caption" color="text.secondary">
                        {t('Generating title...', 'جارٍ توليد العنوان...')}
                      </Typography>
                    </Box>
                  )}
                  <TextField
                    label={t('Title (English)', 'العنوان (إنجليزي)')}
                    fullWidth
                    value={form.titleEn}
                    onChange={handleFormChange('titleEn')}
                    disabled={!titleAutoGenerated.en}
                    helperText={
                      !titleAutoGenerated.en
                        ? t('Title will be generated automatically after filling all fields', 'سيتم توليد العنوان تلقائياً بعد ملء كافة الخانات')
                        : titleAutoGenerated.en && form.titleEn?.trim()
                        ? t('Auto-generated - you can edit', 'مولّد تلقائياً - يمكنك التعديل')
                        : ' '
                    }
                    InputProps={{
                      endAdornment: titleAutoGenerated.en && form.titleEn?.trim() && (
                        <InputAdornment position="end">
                          <Tooltip title={t('Auto-generated', 'مولّد تلقائياً')}>
                            <AutoAwesomeIcon fontSize="small" sx={{ color: '#8a4baf' }} />
                          </Tooltip>
                        </InputAdornment>
                      ),
                    }}
                    inputProps={{ maxLength: 80 }}
                  />
                </Grid>
                <Grid item xs={12} sm={6} md={4}>
                  <TextField
                    type="datetime-local"
                    label={t('Date', 'التاريخ')}
                    value={form.dateStr}
                    onChange={handleFormChange('dateStr')}
                    fullWidth
                    InputLabelProps={{ shrink: true }}
                    helperText=" "
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <EventIcon fontSize="small" />
                        </InputAdornment>
                      ),
                    }}
                  />
                </Grid>
              </Grid>
            </Paper>

            {/* Clinical Section */}
            <Paper 
              elevation={0}
              sx={{ 
                p: 3.5, 
                mb: 3, 
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.95) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04)',
                transition: 'all 0.3s ease',
                '&:hover': {
                  boxShadow: '0 12px 40px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.06)',
                  transform: 'translateY(-2px)',
                },
                position: 'relative',
                overflow: 'hidden',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '5px',
                  height: '100%',
                  background: 'linear-gradient(180deg, #4caf50 0%, #66bb6a 50%, #81c784 100%)',
                  transition: 'all 0.3s ease',
                },
              }}
            >
              <Stack direction="row" alignItems="center" spacing={1.5} sx={{ mb: 2.5 }}>
                <Box
                  sx={{
                    width: 48,
                    height: 48,
                    borderRadius: 3,
                    background: 'linear-gradient(135deg, #4caf50 0%, #66bb6a 100%)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: '0 4px 16px rgba(76, 175, 80, 0.3)',
                  }}
                >
                  <HealingIcon sx={{ color: 'white', fontSize: 24 }} />
                </Box>
                <Typography 
                  variant="h6" 
                  fontWeight={800}
                  sx={{
                    background: 'linear-gradient(135deg, #4caf50 0%, #66bb6a 100%)',
                    backgroundClip: 'text',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                  }}
                >
                  {t('Clinical Details', 'التفاصيل السريرية')}
                </Typography>
              </Stack>
              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <AISuggestionsBox 
                    field="chiefComplaint" 
                    onSelect={(val) => insertSuggestion('chiefComplaint', val)} 
                  />
                  <TextField
                    label={t('Chief Complaint', 'الشكوى الرئيسية')}
                    fullWidth
                    value={form.chiefComplaint}
                    onChange={handleFormChange('chiefComplaint')}
                    onFocus={handleFieldFocus('chiefComplaint')}
                    inputProps={{ maxLength: 160 }}
                    helperText={`${form.chiefComplaint.length}/160`}
                  />
                </Grid>
                <Grid item xs={12} md={6}>
                  <AISuggestionsBox 
                    field="diagnosis" 
                    onSelect={(val) => insertSuggestion('diagnosis', val)} 
                  />
                  <TextField
                    label={t('Diagnosis (ICD if available)', 'التشخيص (إن وُجد ICD)')}
                    fullWidth
                    value={form.diagnosis}
                    onChange={handleFormChange('diagnosis')}
                    onFocus={handleFieldFocus('diagnosis')}
                    helperText={`${form.diagnosis.length}/200`}
                    inputProps={{ maxLength: 200 }}
                  />
                </Grid>
                <Grid item xs={12} md={6}>
                  <AISuggestionsBox 
                    field="findings" 
                    onSelect={(val) => insertSuggestion('findings', val)} 
                  />
                  <TextField
                    label={t('Findings / Examination', 'النتائج / الفحص')}
                    fullWidth
                    multiline
                    minRows={3}
                    value={form.findings}
                    onChange={handleFormChange('findings')}
                    onFocus={handleFieldFocus('findings')}
                    inputProps={{ maxLength: 800 }}
                    helperText={`${form.findings.length}/800`}
                  />
                </Grid>
                <Grid item xs={12} md={6}>
                  <AISuggestionsBox 
                    field="procedures" 
                    onSelect={(val) => insertSuggestion('procedures', val)} 
                  />
                  <TextField
                    label={t('Procedures (CPT if available)', 'الإجراءات (إن وُجد CPT)')}
                    fullWidth
                    multiline
                    minRows={3}
                    value={form.procedures}
                    onChange={handleFormChange('procedures')}
                    onFocus={handleFieldFocus('procedures')}
                    inputProps={{ maxLength: 600 }}
                    helperText={`${form.procedures.length}/600`}
                  />
                </Grid>
              </Grid>
            </Paper>

            {/* Vitals Section */}
            <Paper 
              elevation={0}
              sx={{ 
                p: 3.5, 
                mb: 3, 
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.95) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04)',
                transition: 'all 0.3s ease',
                '&:hover': {
                  boxShadow: '0 12px 40px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.06)',
                  transform: 'translateY(-2px)',
                },
                position: 'relative',
                overflow: 'hidden',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '5px',
                  height: '100%',
                  background: 'linear-gradient(180deg, #f44336 0%, #ef5350 50%, #e57373 100%)',
                  transition: 'all 0.3s ease',
                },
              }}
            >
              <Stack direction="row" alignItems="center" spacing={1.5} sx={{ mb: 2.5 }}>
                <Box
                  sx={{
                    width: 48,
                    height: 48,
                    borderRadius: 3,
                    background: 'linear-gradient(135deg, #f44336 0%, #ef5350 100%)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: '0 4px 16px rgba(244, 67, 54, 0.3)',
                  }}
                >
                  <FavoriteIcon sx={{ color: 'white', fontSize: 24 }} />
                </Box>
                <Typography 
                  variant="h6" 
                  fontWeight={800}
                  sx={{
                    background: 'linear-gradient(135deg, #f44336 0%, #ef5350 100%)',
                    backgroundClip: 'text',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                  }}
                >
                  {t('Vital Signs', 'العلامات الحيوية')}
                </Typography>
              </Stack>
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6} md={3}>
                  <Autocomplete
                    freeSolo
                    options={['100/60', '105/65', '110/70', '115/75', '120/80', '125/85', '130/90', '135/95', '140/100']}
                    value={form.vitalsBP || null}
                    onChange={(event, newValue) => {
                      setForm((prev) => ({ ...prev, vitalsBP: newValue || '' }));
                    }}
                    onInputChange={(event, newInputValue) => {
                      setForm((prev) => ({ ...prev, vitalsBP: newInputValue }));
                    }}
                    renderInput={(params) => (
                  <TextField
                        {...params}
                    label={t('Blood Pressure', 'ضغط الدم')}
                    InputProps={{
                          ...params.InputProps,
                          endAdornment: (
                            <>
                              <InputAdornment position="end" sx={{ mr: 1 }}>mmHg</InputAdornment>
                              {params.InputProps.endAdornment}
                            </>
                          ),
                        }}
                      />
                    )}
                  />
                </Grid>
                <Grid item xs={12} sm={6} md={3}>
                  <Autocomplete
                    freeSolo
                    options={['55', '60', '65', '70', '75', '80', '85', '90', '95', '100', '110']}
                    value={form.vitalsHR || null}
                    onChange={(event, newValue) => {
                      setForm((prev) => ({ ...prev, vitalsHR: newValue || '' }));
                    }}
                    onInputChange={(event, newInputValue) => {
                      setForm((prev) => ({ ...prev, vitalsHR: newInputValue }));
                    }}
                    renderInput={(params) => (
                  <TextField
                        {...params}
                    label={t('Heart Rate', 'نبض القلب')}
                    InputProps={{
                          ...params.InputProps,
                          endAdornment: (
                            <>
                              <InputAdornment position="end" sx={{ mr: 1 }}>bpm</InputAdornment>
                              {params.InputProps.endAdornment}
                            </>
                          ),
                        }}
                      />
                    )}
                  />
                </Grid>
                <Grid item xs={12} sm={6} md={3}>
                  <Autocomplete
                    freeSolo
                    options={['36.0', '36.3', '36.5', '36.7', '37.0', '37.3', '37.5', '37.8', '38.0', '38.5', '39.0']}
                    value={form.vitalsTemp || null}
                    onChange={(event, newValue) => {
                      setForm((prev) => ({ ...prev, vitalsTemp: newValue || '' }));
                    }}
                    onInputChange={(event, newInputValue) => {
                      setForm((prev) => ({ ...prev, vitalsTemp: newInputValue }));
                    }}
                    renderInput={(params) => (
                  <TextField
                        {...params}
                    label={t('Temperature', 'درجة الحرارة')}
                    InputProps={{
                          ...params.InputProps,
                          endAdornment: (
                            <>
                              <InputAdornment position="end" sx={{ mr: 1 }}>°C</InputAdornment>
                              {params.InputProps.endAdornment}
                            </>
                          ),
                        }}
                      />
                    )}
                  />
                </Grid>
                <Grid item xs={12} sm={6} md={3}>
                  <Autocomplete
                    freeSolo
                    options={['90', '92', '93', '94', '95', '96', '97', '98', '99', '100']}
                    value={form.vitalsSpO2 || null}
                    onChange={(event, newValue) => {
                      setForm((prev) => ({ ...prev, vitalsSpO2: newValue || '' }));
                    }}
                    onInputChange={(event, newInputValue) => {
                      setForm((prev) => ({ ...prev, vitalsSpO2: newInputValue }));
                    }}
                    renderInput={(params) => (
                  <TextField
                        {...params}
                    label={t('SpO₂', 'نسبة الأوكسجين')}
                    InputProps={{
                          ...params.InputProps,
                          endAdornment: (
                            <>
                              <InputAdornment position="end" sx={{ mr: 1 }}>%</InputAdornment>
                              {params.InputProps.endAdornment}
                            </>
                          ),
                        }}
                      />
                    )}
                  />
                </Grid>
                {extraVitalsFields.map((field) => (
                  <Grid item xs={12} sm={6} md={3} key={field.key}>
                    <TextField
                      label={field.label}
                      value={form[`vitals${field.key.toUpperCase()}`] || ''}
                      onChange={handleVitalsChange(field.key)}
                      fullWidth
                      InputProps={{
                        endAdornment: field.unit ? <InputAdornment position="end">{field.unit}</InputAdornment> : null,
                      }}
                    />
                  </Grid>
                ))}
              </Grid>
              <Box sx={{ mt: 3 }}>
                <Button
                  startIcon={<AddCircleOutlineIcon />}
                  onClick={() => setVitalsDialogOpen(true)}
                  variant="outlined"
                >
                  {t('Add Field', 'إضافة حقل جديد')}
                </Button>
              </Box>
              <Dialog open={vitalsDialogOpen} onClose={() => setVitalsDialogOpen(false)}>
                <DialogTitle>{t('Add New Field', 'إضافة حقل جديد')}</DialogTitle>
                <DialogContent sx={{ pt: 2 }}>
                  <FormControl fullWidth sx={{ mb: 2 }}>
                    <InputLabel>{t('Select Field', 'اختر الحقل')}</InputLabel>
                    <Select
                      value={selectedVitalField}
                      label={t('Select Field', 'اختر الحقل')}
                      onChange={(e) => setSelectedVitalField(e.target.value)}
                    >
                      {availableVitalsFields.map((f) => (
                        <MenuItem key={f.key} value={f.key}>{f.label}</MenuItem>
                      ))}
                      <MenuItem value="custom">{t('Custom Field', 'حقل مخصص')}</MenuItem>
                    </Select>
                  </FormControl>
                  {selectedVitalField === 'custom' && (
                    <TextField
                      label={t('Custom Field Name', 'اسم الحقل المخصص')}
                      value={customVitalField}
                      onChange={(e) => setCustomVitalField(e.target.value)}
                      fullWidth
                    />
                  )}
                </DialogContent>
                <DialogActions>
                  <Button onClick={() => setVitalsDialogOpen(false)}>{t('Cancel', 'إلغاء')}</Button>
                  <Button onClick={handleAddVitalField} variant="contained">{t('Add', 'إضافة')}</Button>
                </DialogActions>
              </Dialog>
            </Paper>

            {/* Medications */}
            <Paper 
              elevation={0}
              sx={{ 
                p: 3.5, 
                mb: 3, 
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.95) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04)',
                transition: 'all 0.3s ease',
                '&:hover': {
                  boxShadow: '0 12px 40px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.06)',
                  transform: 'translateY(-2px)',
                },
                position: 'relative',
                overflow: 'hidden',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '5px',
                  height: '100%',
                  background: 'linear-gradient(180deg, #2196f3 0%, #42a5f5 50%, #64b5f6 100%)',
                  transition: 'all 0.3s ease',
                },
              }}
            >
              <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 2.5 }}>
                <Stack direction="row" alignItems="center" spacing={1.5}>
                  <Box
                    sx={{
                      width: 48,
                      height: 48,
                      borderRadius: 3,
                      background: 'linear-gradient(135deg, #2196f3 0%, #42a5f5 100%)',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      boxShadow: '0 4px 16px rgba(33, 150, 243, 0.3)',
                    }}
                  >
                    <MedicationIcon sx={{ color: 'white', fontSize: 24 }} />
                  </Box>
                  <Typography 
                    variant="h6" 
                    fontWeight={800}
                    sx={{
                      background: 'linear-gradient(135deg, #2196f3 0%, #42a5f5 100%)',
                      backgroundClip: 'text',
                      WebkitBackgroundClip: 'text',
                      WebkitTextFillColor: 'transparent',
                    }}
                  >
                    {t('Medications', 'الأدوية')}
                  </Typography>
                </Stack>
                <Button
                  size="small"
                  startIcon={<AddCircleOutlineIcon />}
                  onClick={addMedication}
                  variant="outlined"
                  sx={{
                    borderRadius: 2.5,
                    textTransform: 'none',
                    fontWeight: 700,
                    borderWidth: 2,
                    '&:hover': {
                      borderWidth: 2,
                      transform: 'translateY(-2px)',
                      boxShadow: '0 4px 12px rgba(33, 150, 243, 0.2)',
                    },
                    transition: 'all 0.2s ease',
                  }}
                >
                  {t('Add', 'إضافة')}
                </Button>
              </Stack>

              <Stack spacing={2}>
                {medicationsList.map((m, idx) => (
                  <Paper
                    key={idx}
                    variant="outlined"
                    sx={{
                      p: 2,
                      borderRadius: 2,
                      borderStyle: 'dashed',
                      borderColor: (t) => alpha(t.palette.divider, 0.8),
                      position: 'relative',
                      zIndex: 1,
                      '&:has(.MuiAutocomplete-popper)': {
                        zIndex: 10,
                      },
                    }}
                  >
                    <Grid container spacing={1.5} alignItems="flex-start">
                      <Grid item xs={12} sx={{ width: '100%' }}>
                        <Box sx={{ width: '100%' }}>
                          <Autocomplete
                            freeSolo
                            autoHighlight
                            loading={drugLoading}
                            disablePortal={true}
                            openOnFocus={false}
                            options={filterDrugs(m.name || '', drugOptions)}
                            value={m.name || null}
                            onChange={(event, newValue) => {
                              // Handle selection from list or clearing
                              if (newValue) {
                                const selectedName = typeof newValue === 'string' 
                                  ? newValue 
                                  : (newValue.displayName || newValue.brandName || newValue.genericName || '');
                                updateMedication(idx, 'name', selectedName);
                              } else {
                                // Clear the field
                                updateMedication(idx, 'name', '');
                              }
                            }}
                            onInputChange={(event, newInputValue, reason) => {
                              // Handle typing/free text input
                              // Update only when user types (not when selecting from list or clearing)
                              if (reason === 'input') {
                                updateMedication(idx, 'name', newInputValue || '');
                              }
                            }}
                            getOptionLabel={(opt) => {
                              if (typeof opt === 'string') return opt;
                              return opt.displayName || opt.brandName || opt.genericName || '';
                            }}
                            renderOption={(props, option) => {
                              // Render medicine options with clear display
                              if (typeof option === 'string') {
                                return (
                                  <Box component="li" {...props} sx={{ py: 1.5, whiteSpace: 'normal', wordBreak: 'break-word' }}>
                                    <Typography variant="body2" fontWeight={600} sx={{ width: '100%' }}>
                                      {option}
                                    </Typography>
                                  </Box>
                                );
                              }
                              
                              // Get all possible name fields
                              const displayName = String(option.displayName || option.brandName || option.name || '').trim();
                              const genericName = String(option.genericName || option.scientificName || '').trim();
                              
                              // Always show displayName as primary (it contains the full name with form)
                              // Show genericName if it exists and is different (even if similar, show it for clarity)
                              const primaryName = displayName || genericName || '—';
                              const showGeneric = genericName && genericName.length > 0 && genericName !== primaryName;
                              
                              return (
                                <Box component="li" {...props} sx={{ py: 1.5, px: 1.5, whiteSpace: 'normal', wordBreak: 'break-word' }}>
                                  <Stack spacing={0.5} sx={{ width: '100%' }}>
                                    <Typography 
                                      variant="body2" 
                                      fontWeight={700} 
                                      sx={{ 
                                        color: 'primary.main',
                                        width: '100%',
                                        wordBreak: 'break-word',
                                        lineHeight: 1.4,
                                      }}
                                    >
                                      {primaryName}
                                    </Typography>
                                    {showGeneric && (
                                      <Typography 
                                        variant="caption" 
                                        color="text.secondary" 
                                        sx={{ 
                                          fontSize: '0.75rem',
                                          width: '100%',
                                          wordBreak: 'break-word',
                                          lineHeight: 1.3,
                                        }}
                                      >
                                        {t('Generic', 'الاسم العلمي')}: {genericName}
                                      </Typography>
                                    )}
                                  </Stack>
                                </Box>
                              );
                            }}
                            isOptionEqualToValue={(option, value) => {
                              // Compare options properly
                              if (typeof option === 'string' && typeof value === 'string') {
                                return option === value;
                              }
                              if (typeof option === 'object' && typeof value === 'string') {
                                const optionName = option.displayName || option.brandName || option.genericName || '';
                                return optionName === value;
                              }
                              return false;
                            }}
                            ListboxProps={{
                              sx: {
                                maxHeight: '400px',
                                width: '100%',
                                '& .MuiAutocomplete-option': {
                                  minHeight: 'auto',
                                  padding: '12px 16px',
                                  whiteSpace: 'normal',
                                  wordBreak: 'break-word',
                                },
                              },
                            }}
                            slotProps={{
                              popper: {
                                placement: 'bottom-start',
                                disablePortal: true,
                                modifiers: [
                                  {
                                    name: 'offset',
                                    options: {
                                      offset: [0, 4],
                                    },
                                  },
                                  {
                                    name: 'preventOverflow',
                                    enabled: true,
                                    options: {
                                      altAxis: false,
                                      altBoundary: false,
                                      tether: false,
                                      rootBoundary: 'clippingParents',
                                      padding: 8,
                                    },
                                  },
                                  {
                                    name: 'flip',
                                    enabled: false,
                                  },
                                ],
                              },
                              paper: {
                                sx: {
                                  minWidth: '100%',
                                  width: 'max-content',
                                  maxWidth: '600px',
                                  '@media (min-width: 960px)': {
                                    maxWidth: '800px',
                                  },
                                  mt: 0.5,
                                  boxShadow: '0 4px 20px rgba(0,0,0,0.12)',
                                  border: '1px solid',
                                  borderColor: 'divider',
                                },
                              },
                            }}
                            renderInput={(params) => (
                              <TextField
                                {...params}
                                label={t('Medicine name', 'اسم الدواء')}
                                fullWidth
                                size="small"
                                placeholder={t('Type or select medicine', 'اكتب أو اختر الدواء')}
                              />
                            )}
                            sx={{ width: '100%', minWidth: 0 }}
                          />
                        </Box>
                      </Grid>
                      <Grid item xs={6} md={2}>
                        <TextField
                          label={t('Dose', 'الجرعة')}
                          fullWidth
                          size="small"
                          value={m.dose}
                          onChange={(e) => updateMedication(idx, 'dose', e.target.value)}
                        />
                      </Grid>
                      <Grid item xs={6} md={2}>
                        <TextField
                          label={t('Frequency', 'التكرار')}
                          fullWidth
                          size="small"
                          value={m.frequency}
                          onChange={(e) => updateMedication(idx, 'frequency', e.target.value)}
                        />
                      </Grid>
                      <Grid item xs={6} md={2}>
                        <TextField
                          label={t('Duration', 'المدة')}
                          fullWidth
                          size="small"
                          value={m.duration}
                          onChange={(e) => updateMedication(idx, 'duration', e.target.value)}
                        />
                      </Grid>
                      <Grid item xs={6} md={1.5}>
                        <IconButton
                          color="error"
                          onClick={() => removeMedication(idx)}
                          size="small"
                        >
                          <DeleteOutlineIcon />
                        </IconButton>
                      </Grid>
                    </Grid>
                  </Paper>
                ))}
              </Stack>
            </Paper>

            {/* Tests */}
            <Paper 
              elevation={0}
              sx={{ 
                p: 3.5, 
                mb: 3, 
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.95) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04)',
                transition: 'all 0.3s ease',
                '&:hover': {
                  boxShadow: '0 12px 40px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.06)',
                  transform: 'translateY(-2px)',
                },
                position: 'relative',
                overflow: 'hidden',
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '5px',
                  height: '100%',
                  background: 'linear-gradient(180deg, #00bcd4 0%, #26c6da 50%, #4dd0e1 100%)',
                  transition: 'all 0.3s ease',
                },
              }}
            >
              <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 2.5 }}>
                <Stack direction="row" alignItems="center" spacing={1.5}>
                  <Box
                    sx={{
                      width: 48,
                      height: 48,
                      borderRadius: 3,
                      background: 'linear-gradient(135deg, #00bcd4 0%, #26c6da 100%)',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      boxShadow: '0 4px 16px rgba(0, 188, 212, 0.3)',
                    }}
                  >
                    <ScienceIcon sx={{ color: 'white', fontSize: 24 }} />
                  </Box>
                  <Typography 
                    variant="h6" 
                    fontWeight={800}
                    sx={{
                      background: 'linear-gradient(135deg, #00bcd4 0%, #26c6da 100%)',
                      backgroundClip: 'text',
                      WebkitBackgroundClip: 'text',
                      WebkitTextFillColor: 'transparent',
                    }}
                  >
                    {t('Medical Tests', 'الفحوصات الطبية')}
                  </Typography>
                </Stack>
                <Button
                  size="small"
                  startIcon={<AddCircleOutlineIcon />}
                  onClick={addTest}
                  variant="outlined"
                  sx={{
                    borderRadius: 2.5,
                    textTransform: 'none',
                    fontWeight: 700,
                    borderWidth: 2,
                    borderColor: 'info.main',
                    color: 'info.main',
                    '&:hover': {
                      borderWidth: 2,
                      borderColor: 'info.dark',
                      background: 'rgba(0, 188, 212, 0.08)',
                      transform: 'translateY(-2px)',
                      boxShadow: '0 4px 12px rgba(0, 188, 212, 0.2)',
                    },
                    transition: 'all 0.2s ease',
                  }}
                >
                  {t('Add', 'إضافة')}
                </Button>
              </Stack>

              <Stack spacing={2}>
                {testsList.map((testItem, idx) => (
                  <Paper
                    key={idx}
                    elevation={0}
                    sx={{
                      p: 2.5,
                      borderRadius: 3,
                      borderStyle: 'dashed',
                      borderWidth: 2,
                      borderColor: (t2) => alpha(t2.palette.info.main, 0.3),
                      background: 'linear-gradient(135deg, rgba(0, 188, 212, 0.02) 0%, rgba(38, 198, 218, 0.01) 100%)',
                      transition: 'all 0.3s ease',
                      '&:hover': {
                        borderColor: (t2) => alpha(t2.palette.info.main, 0.5),
                        background: 'linear-gradient(135deg, rgba(0, 188, 212, 0.04) 0%, rgba(38, 198, 218, 0.02) 100%)',
                        transform: 'translateY(-2px)',
                        boxShadow: '0 4px 12px rgba(0, 188, 212, 0.1)',
                      },
                    }}
                  >
                    <Grid container spacing={1.5} alignItems="center">
                      <Grid item xs={12} sx={{ width: '100%' }}>
                        <Box sx={{ width: '100%' }}>
                          <Autocomplete
                            freeSolo
                            autoHighlight
                            options={filterTests(testItem.name || '')}
                            loading={testsLoading}
                            value={testItem.name || null}
                            onChange={(event, newValue) => {
                              // Handle selection from list or clearing
                              if (newValue) {
                                const selectedName = typeof newValue === 'string' ? newValue : String(newValue || '');
                                updateTest(idx, 'name', selectedName);
                              } else {
                                // Clear the field
                                updateTest(idx, 'name', '');
                              }
                            }}
                            onInputChange={(event, newInputValue, reason) => {
                              // Handle typing/free text input
                              // Update only when user types (not when selecting from list or clearing)
                              if (reason === 'input') {
                                updateTest(idx, 'name', newInputValue || '');
                              }
                            }}
                            getOptionLabel={(opt) => {
                              if (typeof opt === 'string') return opt;
                              return String(opt || '');
                            }}
                            renderOption={(props, option) => {
                              // Render test options with clear display
                              const testName = typeof option === 'string' ? option : String(option || '');
                              return (
                                <Box component="li" {...props} sx={{ py: 1.5, px: 1.5, whiteSpace: 'normal', wordBreak: 'break-word' }}>
                                  <Typography 
                                    variant="body2" 
                                    fontWeight={700} 
                                    sx={{ 
                                      color: 'primary.main',
                                      width: '100%',
                                      wordBreak: 'break-word',
                                      lineHeight: 1.4,
                                    }}
                                  >
                                    {testName}
                                  </Typography>
                                </Box>
                              );
                            }}
                            isOptionEqualToValue={(option, value) => {
                              // Compare options properly
                              if (typeof option === 'string' && typeof value === 'string') {
                                return option === value;
                              }
                              return String(option || '') === String(value || '');
                            }}
                            ListboxProps={{
                              sx: {
                                maxHeight: '400px',
                                width: '100%',
                                '& .MuiAutocomplete-option': {
                                  minHeight: 'auto',
                                  padding: '12px 16px',
                                  whiteSpace: 'normal',
                                  wordBreak: 'break-word',
                                },
                              },
                            }}
                            slotProps={{
                              popper: {
                                placement: 'bottom-start',
                                disablePortal: true,
                                modifiers: [
                                  {
                                    name: 'offset',
                                    options: {
                                      offset: [0, 4],
                                    },
                                  },
                                  {
                                    name: 'preventOverflow',
                                    enabled: true,
                                    options: {
                                      altAxis: false,
                                      altBoundary: false,
                                      tether: false,
                                      rootBoundary: 'clippingParents',
                                      padding: 8,
                                    },
                                  },
                                  {
                                    name: 'flip',
                                    enabled: false,
                                  },
                                ],
                              },
                              paper: {
                                sx: {
                                  minWidth: '100%',
                                  width: 'max-content',
                                  maxWidth: '600px',
                                  '@media (min-width: 960px)': {
                                    maxWidth: '800px',
                                  },
                                  mt: 0.5,
                                  boxShadow: '0 4px 20px rgba(0,0,0,0.12)',
                                  border: '1px solid',
                                  borderColor: 'divider',
                                },
                              },
                            }}
                            renderInput={(params) => (
                              <TextField
                                {...params}
                                label={t('Test / Investigation', 'الفحص / التحليل')}
                                placeholder={t('Type or select test', 'اكتب أو اختر الفحص')}
                                fullWidth
                                size="small"
                              />
                            )}
                            sx={{ width: '100%', minWidth: 0 }}
                          />
                        </Box>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <TextField
                          label={t('Notes / Instructions', 'ملاحظات / تعليمات')}
                          fullWidth
                          size="small"
                          value={testItem.notes}
                          onChange={(e) => updateTest(idx, 'notes', e.target.value)}
                          placeholder={t('Fasting 8 hours, etc.', 'صيام ٨ ساعات مثلاً')}
                        />
                      </Grid>
                      <Grid item xs={12} md="auto">
                        <IconButton
                          color="error"
                          onClick={() => removeTest(idx)}
                          size="small"
                        >
                          <DeleteOutlineIcon />
                        </IconButton>
                      </Grid>
                    </Grid>
                  </Paper>
                ))}
              </Stack>
            </Paper>

            {/* Actions */}
            <Paper
              elevation={0}
              sx={{
                p: 3,
                borderRadius: 4,
                background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.95) 100%)',
                backdropFilter: 'blur(20px) saturate(180%)',
                WebkitBackdropFilter: 'blur(20px) saturate(180%)',
                border: '1.5px solid',
                borderColor: 'rgba(255,255,255,0.8)',
                boxShadow: '0 8px 32px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04)',
              }}
            >
              <Stack direction="row" spacing={2} justifyContent="flex-end">
                <Button
                  variant="outlined"
                  onClick={() => router.push(`/patient-reports${isArabic ? '?lang=ar' : ''}`)}
                  sx={{
                    borderRadius: 2.5,
                    textTransform: 'none',
                    fontWeight: 700,
                    px: 3,
                    borderWidth: 2,
                    '&:hover': {
                      borderWidth: 2,
                      transform: 'translateY(-2px)',
                      boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
                    },
                    transition: 'all 0.2s ease',
                  }}
                >
                  {t('Cancel', 'إلغاء')}
                </Button>
                <Button
                  variant="contained"
                  onClick={handleSave}
                  disabled={submitting}
                  sx={{
                    minWidth: 140,
                    borderRadius: 2.5,
                    textTransform: 'none',
                    fontWeight: 700,
                    px: 3,
                    background: 'linear-gradient(135deg, #1976d2 0%, #42a5f5 100%)',
                    boxShadow: '0 4px 12px rgba(25, 118, 210, 0.3)',
                    '&:hover': {
                      background: 'linear-gradient(135deg, #1565c0 0%, #1976d2 100%)',
                      boxShadow: '0 6px 16px rgba(25, 118, 210, 0.4)',
                      transform: 'translateY(-2px)',
                    },
                    '&:disabled': {
                      background: 'rgba(0,0,0,0.12)',
                    },
                    transition: 'all 0.2s ease',
                  }}
                >
                  {submitting ? <CircularProgress size={20} color="inherit" /> : t('Save', 'حفظ')}
                </Button>
              </Stack>
            </Paper>
          </Container>
        </Box>

        {/* Snackbar */}
        <Snackbar
          open={snack.open}
          autoHideDuration={4000}
          onClose={() => setSnack((s) => ({ ...s, open: false }))}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert severity={snack.severity}>{snack.msg}</Alert>
        </Snackbar>
      </AppLayout>
    </Protected>
  );
}

